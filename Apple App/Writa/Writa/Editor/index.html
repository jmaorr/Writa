<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <style id="base-styles">
        * { box-sizing: border-box; }
        html, body { 
            margin: 0; 
            padding: 0; 
            background: transparent;
            height: 100%;
            overflow: hidden;
        }
        #editor {
            height: 100%;
            overflow-y: auto;
        }
        .tiptap { outline: none; }
        .tiptap .selectedCell:after {
            z-index: 2;
            position: absolute;
            content: "";
            left: 0; right: 0; top: 0; bottom: 0;
            background: rgba(0, 122, 255, 0.1);
            pointer-events: none;
        }
        
        /* Task Card Styles */
        .task-card-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        
        .task-card {
            position: relative;
            display: flex;
            align-items: flex-start;
            gap: 12px;
            padding: 18px 16px;
            margin: 6px 0;
            border: 1px solid var(--writa-border-color, rgba(128, 128, 128, 0.2));
            border-radius: 16px;
            background: var(--writa-card-bg, rgba(128, 128, 128, 0.05));
            transition: border-color 0.15s ease, box-shadow 0.15s ease;
        }
        
        .task-card:hover {
            border-color: var(--writa-border-hover, rgba(128, 128, 128, 0.3));
        }
        
        .task-card:focus-within {
            border-color: var(--writa-accent-color, #007AFF);
            box-shadow: 0 0 0 3px var(--writa-accent-shadow, rgba(0, 122, 255, 0.15));
        }
        
        .task-card.is-completed {
            opacity: 0.6;
        }
        
        .task-card.is-completed .task-card-title {
            color: var(--writa-text-secondary, #888);
        }
        
        .task-card-checkbox {
            flex-shrink: 0;
            width: 18px;
            height: 18px;
            margin-top: 2px; /* Align with first line of title */
            border: 2px solid var(--writa-checkbox-border, rgba(128, 128, 128, 0.4));
            border-radius: 5px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.15s ease;
            background: transparent;
            user-select: none;
        }
        
        .task-card-checkbox:hover {
            border-color: var(--writa-success-color, #34C759);
            background: rgba(52, 199, 89, 0.15);
        }
        
        .task-card.is-completed .task-card-checkbox {
            background: var(--writa-success-color, #34C759);
            border-color: var(--writa-success-color, #34C759);
        }
        
        .task-card.is-completed .task-card-checkbox::after {
            content: '✓';
            color: white;
            font-size: 11px;
            font-weight: bold;
            line-height: 1;
        }
        
        .task-card-content {
            flex: 1;
            min-width: 0;
        }
        
        .task-card-title {
            font-weight: 500;
            font-size: 0.9em;
            line-height: 1.4;
            outline: none;
            min-height: 1.4em;
        }
        
        .task-card-title.is-empty::before,
        .task-card-title:empty::before {
            content: 'What needs to be done?';
            color: var(--writa-text-placeholder, #999);
            pointer-events: none;
            float: left;
            height: 0;
        }
        
        .task-card-description {
            font-size: 0.8em;
            color: var(--writa-text-secondary, #666);
            line-height: 1.4;
            margin-top: 2px;
            outline: none;
            min-height: 1.4em;
            transition: opacity 0.15s ease, min-height 0.15s ease;
        }
        
        /* Description nodes are now dynamically added/removed, not hidden */
        
        .task-card-title:focus,
        .task-card-description:focus {
            outline: none;
        }
        
        /* TipTap Placeholder styling */
        .tiptap .is-empty::before {
            color: var(--writa-text-placeholder, #999);
            pointer-events: none;
            float: left;
            height: 0;
        }
        
        .tiptap .task-card-title.is-empty::before {
            content: 'What needs to be done?';
        }
        
        .tiptap .task-card-description.is-empty::before {
            content: 'Add notes...';
        }
        
        /* Fallback placeholder using :empty (for when .is-empty isn't added) */
        .task-card-title:not(.is-empty):empty::before,
        .task-card-title > br:only-child::before {
            content: 'What needs to be done?';
            color: var(--writa-text-placeholder, #999);
            pointer-events: none;
        }
        
        .task-card-description:not(.is-empty):empty::before,
        .task-card-description > br:only-child::before {
            content: 'Press Tab for description';
            color: var(--writa-text-placeholder, #999);
            pointer-events: none;
        }
        
        /* Floating Task Card Action Bar */
        #task-action-bar {
            display: none;
            position: fixed;
            gap: 6px;
            align-items: center;
            z-index: 1000;
            pointer-events: auto;
        }
        
        #task-action-bar.visible {
            display: flex;
        }
        
        .task-card-action {
            display: inline-flex;
            align-items: center;
            gap: 2px;
            padding: 2px 4px;
            font-size: 10px;
            color: var(--writa-text-secondary, #666);
            background: transparent;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            white-space: nowrap;
            transition: color 0.15s ease;
        }
        
        .task-card-action:hover {
            color: var(--writa-text-primary, #333);
        }
        
        .task-card-action-shortcut {
            font-size: 9px;
            opacity: 0.7;
        }
        
        .task-card-action--delete:hover {
            color: #FF3B30;
        }
        
        /* Prompt Snippet Styles */
        .prompt-snippet-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        
        .prompt-snippet {
            position: relative;
            display: flex;
            align-items: flex-start;
            gap: 12px;
            padding: 18px 16px;
            margin: 6px 0;
            border: 1px solid var(--writa-border-color, rgba(128, 128, 128, 0.2));
            border-radius: 16px;
            background: var(--writa-card-bg, rgba(128, 128, 128, 0.05));
            transition: border-color 0.15s ease, box-shadow 0.15s ease;
        }
        
        .prompt-snippet:hover {
            border-color: var(--writa-border-hover, rgba(128, 128, 128, 0.3));
        }
        
        .prompt-snippet:focus-within {
            border-color: var(--writa-accent-color, #007AFF);
            box-shadow: 0 0 0 3px var(--writa-accent-shadow, rgba(0, 122, 255, 0.15));
        }
        
        .prompt-snippet-checkbox {
            flex-shrink: 0;
            width: 18px;
            height: 18px;
            margin-top: 2px;
            border: 2px solid var(--writa-checkbox-border, rgba(128, 128, 128, 0.4));
            border-radius: 5px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.15s ease;
            background: transparent;
            user-select: none;
        }
        
        .prompt-snippet-checkbox:hover {
            border-color: var(--writa-success-color, #34C759);
            background: rgba(52, 199, 89, 0.15);
        }
        
        .prompt-snippet.is-completed .prompt-snippet-checkbox {
            background: var(--writa-success-color, #34C759);
            border-color: var(--writa-success-color, #34C759);
        }
        
        .prompt-snippet.is-completed .prompt-snippet-checkbox::after {
            content: '✓';
            color: white;
            font-size: 11px;
            font-weight: bold;
            line-height: 1;
        }
        
        .prompt-snippet.is-completed {
            opacity: 0.6;
        }
        
        .prompt-snippet.is-completed .prompt-snippet-title {
            color: var(--writa-text-secondary, #888);
        }
        
        .prompt-snippet-content {
            flex: 1;
            min-width: 0;
        }
        
        .prompt-snippet-title {
            font-weight: 500;
            font-size: 0.9em;
            line-height: 1.4;
            outline: none;
            min-height: 1.4em;
            padding-right: 180px; /* Space for action buttons */
        }
        
        .prompt-snippet-title.is-empty::before {
            content: 'Snippet title...';
            color: var(--writa-text-placeholder, #999);
            pointer-events: none;
            float: left;
            height: 0;
        }
        
        .prompt-snippet-body {
            font-size: 0.8em;
            color: var(--writa-text-secondary, #666);
            line-height: 1.4;
            margin-top: 2px;
            outline: none;
            min-height: 1.4em;
        }
        
        .prompt-snippet-body.is-empty::before {
            content: 'Write your prompt here...';
            color: var(--writa-text-placeholder, #999);
            pointer-events: none;
            float: left;
            height: 0;
        }
        
        .prompt-snippet-actions {
            position: absolute;
            top: 8px;
            right: 8px;
            display: flex;
            gap: 4px;
        }
        
        .prompt-snippet-action {
            display: inline-flex;
            align-items: center;
            gap: 3px;
            padding: 3px 8px;
            font-size: 11px;
            color: var(--writa-text-secondary, #666);
            background: transparent;
            border: 1px solid var(--writa-border-color, rgba(128, 128, 128, 0.2));
            border-radius: 6px;
            cursor: pointer;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            transition: all 0.15s ease;
        }
        
        .prompt-snippet-action:hover {
            background: var(--writa-card-bg, rgba(128, 128, 128, 0.1));
            border-color: var(--writa-border-hover, rgba(128, 128, 128, 0.3));
        }
        
        .prompt-snippet-action--done {
            color: var(--writa-success-color, #34C759);
            border-color: var(--writa-success-color, #34C759);
        }
        
        .prompt-snippet-action--done:hover {
            background: rgba(52, 199, 89, 0.1);
        }
        
        .prompt-snippet-action--delete {
            color: var(--writa-text-secondary, #888);
        }
        
        .prompt-snippet-action--delete:hover {
            color: #FF3B30;
            border-color: #FF3B30;
            background: rgba(255, 59, 48, 0.1);
        }
        
        .prompt-snippet-action-icon {
            font-size: 12px;
            line-height: 1;
        }
        
        /* Collapsed state */
        .prompt-snippet.is-collapsed {
            cursor: pointer;
        }
        
        .prompt-snippet.is-collapsed:hover {
            background: var(--writa-card-hover-bg, rgba(128, 128, 128, 0.08));
        }
        
        .prompt-snippet.is-collapsed .prompt-snippet-content {
            display: none;
            pointer-events: none;
        }
        
        .prompt-snippet.is-collapsed .prompt-snippet-actions {
            display: none;
        }
        
        .prompt-snippet-preview {
            display: none;
            flex: 1;
            min-width: 0;
        }
        
        .prompt-snippet.is-collapsed .prompt-snippet-preview {
            display: block;
        }
        
        .prompt-snippet-preview-title {
            font-weight: 500;
            font-size: 0.9em;
            color: var(--writa-text-primary, #333);
            line-height: 1.4;
            padding-right: 120px; /* Space for Edit/Copy buttons */
            pointer-events: none;
            user-select: none;
        }
        
        .prompt-snippet-preview-body {
            font-size: 0.8em;
            color: var(--writa-text-secondary, #888);
            line-height: 1.4;
            margin-top: 2px;
            overflow: hidden;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            pointer-events: none;
            user-select: none;
        }
        
        .prompt-snippet-preview-actions {
            display: none;
            position: absolute;
            top: 8px;
            right: 8px;
            gap: 4px;
        }
        
        .prompt-snippet.is-collapsed .prompt-snippet-preview-actions {
            display: flex;
        }
        
        /* Copy feedback */
        .prompt-snippet-copy-feedback {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 8px 16px;
            background: var(--writa-success-color, #34C759);
            color: white;
            border-radius: 8px;
            font-size: 13px;
            font-weight: 500;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease;
            z-index: 10;
        }
        
        .prompt-snippet-copy-feedback.visible {
            opacity: 1;
        }
    </style>
    <style id="theme-styles"></style>
</head>
<body>
    <div id="editor"></div>
    
    <!-- Floating action bar for task cards -->
    <div id="task-action-bar">
        <button type="button" class="task-card-action" data-action="new-task">
            <span class="task-card-action-shortcut">↵</span> New Task
        </button>
        <button type="button" class="task-card-action" data-action="description">
            <span class="task-card-action-shortcut">⇥</span> Description
        </button>
        <button type="button" class="task-card-action task-card-action--delete" data-action="delete">
            Delete
        </button>
    </div>
    
    <script type="module">
        import { Editor, Node, mergeAttributes } from 'https://esm.sh/@tiptap/core@2.1.13'
        import StarterKit from 'https://esm.sh/@tiptap/starter-kit@2.1.13'
        import Placeholder from 'https://esm.sh/@tiptap/extension-placeholder@2.1.13'
        import Underline from 'https://esm.sh/@tiptap/extension-underline@2.1.13'
        import Link from 'https://esm.sh/@tiptap/extension-link@2.1.13'
        import TaskList from 'https://esm.sh/@tiptap/extension-task-list@2.1.13'
        import TaskItem from 'https://esm.sh/@tiptap/extension-task-item@2.1.13'
        import Image from 'https://esm.sh/@tiptap/extension-image@2.1.13'
        import Table from 'https://esm.sh/@tiptap/extension-table@2.1.13'
        import TableRow from 'https://esm.sh/@tiptap/extension-table-row@2.1.13'
        import TableCell from 'https://esm.sh/@tiptap/extension-table-cell@2.1.13'
        import TableHeader from 'https://esm.sh/@tiptap/extension-table-header@2.1.13'
        import Highlight from 'https://esm.sh/@tiptap/extension-highlight@2.1.13'
        import TextAlign from 'https://esm.sh/@tiptap/extension-text-align@2.1.13'
        import Subscript from 'https://esm.sh/@tiptap/extension-subscript@2.1.13'
        import Superscript from 'https://esm.sh/@tiptap/extension-superscript@2.1.13'
        import Color from 'https://esm.sh/@tiptap/extension-color@2.1.13'
        import TextStyle from 'https://esm.sh/@tiptap/extension-text-style@2.1.13'
        
        // ============================================
        // Helper: Find ancestor node at a specific depth
        // ============================================
        function findAncestor($pos, typeName) {
            for (let d = $pos.depth; d > 0; d--) {
                if ($pos.node(d).type.name === typeName) {
                    return { node: $pos.node(d), depth: d }
                }
            }
            return null
        }
        
        // Helper: Check if a task card is empty (no text in title or description)
        function isTaskCardEmpty(taskCard) {
            let empty = true
            taskCard.forEach(child => {
                if (child.textContent.length > 0) empty = false
            })
            return empty
        }
        
        // Helper: Create a new empty task card node (without description - added on Tab)
        function createTaskCard(schema, includeDescription = false) {
            const title = schema.nodes.taskCardTitle.create()
            if (includeDescription) {
                const description = schema.nodes.taskCardDescription.create()
                return schema.nodes.taskCard.create({ checked: false }, [title, description])
            }
            return schema.nodes.taskCard.create({ checked: false }, [title])
        }
        
        // ============================================
        // TaskCardList Node
        // ============================================
        const TaskCardList = Node.create({
            name: 'taskCardList',
            group: 'block',
            content: 'taskCard+',
            
            parseHTML() {
                return [{ tag: 'div[data-type="task-card-list"]' }]
            },
            
            renderHTML({ HTMLAttributes }) {
                return ['div', mergeAttributes(HTMLAttributes, { 
                    'data-type': 'task-card-list',
                    'class': 'task-card-list'
                }), 0]
            }
        })
        
        // ============================================
        // TaskCard Node
        // ============================================
        const TaskCard = Node.create({
            name: 'taskCard',
            group: 'block',
            content: 'taskCardTitle taskCardDescription?',
            defining: true,
            
            addAttributes() {
                return {
                    checked: {
                        default: false,
                        parseHTML: el => el.getAttribute('data-checked') === 'true',
                        renderHTML: attrs => ({ 'data-checked': attrs.checked ? 'true' : 'false' })
                    }
                }
            },
            
            parseHTML() {
                return [{ tag: 'div[data-type="task-card"]' }]
            },
            
            renderHTML({ node, HTMLAttributes }) {
                return ['div', mergeAttributes(HTMLAttributes, { 
                    'data-type': 'task-card',
                    'class': `task-card ${node.attrs.checked ? 'is-completed' : ''}`
                }), 
                    ['div', { class: 'task-card-checkbox' }],
                    ['div', { class: 'task-card-content' }, 0]
                ]
            },
            
            addCommands() {
                return {
                    // Insert a new task card (or list with task card if not in one)
                    insertTaskCard: () => ({ chain, state, editor }) => {
                        const { schema, selection: { $from } } = state
                        const taskCard = createTaskCard(schema)
                        
                        // If already in a task card list, insert after current task
                        if (editor.isActive('taskCardList')) {
                            const ancestor = findAncestor($from, 'taskCard')
                            if (ancestor) {
                                const insertPos = $from.after(ancestor.depth)
                                // Position: +1 into taskCard, +1 into title
                                return chain()
                                    .insertContentAt(insertPos, taskCard.toJSON())
                                    .setTextSelection(insertPos + 2)
                                    .run()
                            }
                        }
                        
                        // Create new list - replace current block entirely
                        // Use before/after to get positions OUTSIDE the block (not inside)
                        const blockStart = $from.before($from.depth)
                        const blockEnd = $from.after($from.depth)
                        const taskCardList = schema.nodes.taskCardList.create(null, [taskCard])
                        
                        // Position: +1 into list, +1 into taskCard, +1 into title
                        return chain()
                            .deleteRange({ from: blockStart, to: blockEnd })
                            .insertContentAt(blockStart, taskCardList.toJSON())
                            .setTextSelection(blockStart + 3)
                            .run()
                    },
                    
                    // Toggle the checked state of the current task card
                    // Uses direct transaction since TipTap lacks ancestor attribute commands
                    toggleTaskCardChecked: () => ({ tr, state, dispatch }) => {
                        const ancestor = findAncestor(state.selection.$from, 'taskCard')
                        if (!ancestor) return false
                        
                        if (dispatch) {
                            const pos = state.selection.$from.before(ancestor.depth)
                            tr.setNodeMarkup(pos, undefined, {
                                ...ancestor.node.attrs,
                                checked: !ancestor.node.attrs.checked
                            })
                            dispatch(tr)
                        }
                        return true
                    }
                }
            },
            
            addKeyboardShortcuts() {
                return {
                    // Toggle completion with Cmd/Ctrl+Enter
                    'Mod-Enter': () => this.editor.commands.toggleTaskCardChecked(),
                    
                    // Enter: create new task or exit if empty
                    'Enter': ({ editor }) => {
                        if (!editor.isActive('taskCard')) return false
                        
                        const { state } = editor
                        const { $from } = state.selection
                        const taskAncestor = findAncestor($from, 'taskCard')
                        if (!taskAncestor) return false
                        
                        const { node: taskCard, depth: taskCardDepth } = taskAncestor
                        
                        // If task is empty, exit task card formatting
                        if (isTaskCardEmpty(taskCard)) {
                            const listAncestor = findAncestor($from, 'taskCardList')
                            if (!listAncestor) return false
                            
                            const { node: list, depth: listDepth } = listAncestor
                            const listEnd = $from.after(listDepth)
                            
                            if (list.childCount === 1) {
                                // Only task in list - replace entire list with paragraph
                                const listStart = $from.before(listDepth)
                                return editor.chain()
                                    .deleteRange({ from: listStart, to: listEnd })
                                    .insertContentAt(listStart, { type: 'paragraph' })
                                    .setTextSelection(listStart + 1)
                                    .run()
                            } else {
                                // Multiple tasks - delete this one and insert paragraph after list
                                const taskStart = $from.before(taskCardDepth)
                                const taskEnd = $from.after(taskCardDepth)
                                return editor.chain()
                                    .deleteRange({ from: taskStart, to: taskEnd })
                                    .insertContentAt(listEnd - (taskEnd - taskStart), { type: 'paragraph' })
                                    .setTextSelection(listEnd - (taskEnd - taskStart) + 1)
                                    .run()
                            }
                        }
                        
                        // Not empty - create new task after current
                        const insertPos = $from.after(taskCardDepth)
                        return editor.chain()
                            .insertContentAt(insertPos, createTaskCard(state.schema).toJSON())
                            .setTextSelection(insertPos + 2) // +1 taskCard, +1 title
                            .run()
                    },
                    
                    // Tab: move from title to description (create if doesn't exist)
                    'Tab': ({ editor }) => {
                        if (!editor.isActive('taskCard')) return false
                        
                        const { state } = editor
                        const { $from } = state.selection
                        const titleAncestor = findAncestor($from, 'taskCardTitle')
                        if (!titleAncestor) return false
                        
                        const taskCardDepth = titleAncestor.depth - 1
                        const taskCard = $from.node(taskCardDepth)
                        const taskCardStart = $from.before(taskCardDepth)
                        
                        // Check if description exists
                        let hasDescription = false
                        let descPos = null
                        let offset = 1
                        taskCard.forEach(child => {
                            if (child.type.name === 'taskCardTitle') {
                                offset += child.nodeSize
                            } else if (child.type.name === 'taskCardDescription') {
                                hasDescription = true
                                descPos = taskCardStart + offset + 1
                            }
                        })
                        
                        if (hasDescription && descPos) {
                            // Move to existing description
                            return editor.commands.setTextSelection(descPos)
                        }
                        
                        // Create new description at end of taskCard
                        const insertPos = $from.after(taskCardDepth) - 1 // Before taskCard closes
                        const newDesc = state.schema.nodes.taskCardDescription.create()
                        
                        return editor.chain()
                            .insertContentAt(insertPos, newDesc.toJSON())
                            .setTextSelection(insertPos + 1) // Inside new description
                            .run()
                    },
                    
                    // Shift+Tab: move from description to title
                    'Shift-Tab': ({ editor }) => {
                        if (!editor.isActive('taskCard')) return false
                        
                        const { $from } = editor.state.selection
                        const descAncestor = findAncestor($from, 'taskCardDescription')
                        if (!descAncestor) return false
                        
                        const taskCardStart = $from.before(descAncestor.depth - 1)
                        // Title position: +1 (into taskCard), +1 (into title)
                        return editor.commands.setTextSelection(taskCardStart + 2)
                    },
                    
                    // Backspace at start of empty title: exit task formatting
                    'Backspace': ({ editor }) => {
                        if (!editor.isActive('taskCard')) return false
                        
                        const { selection, selection: { $from } } = editor.state
                        
                        // Only handle empty selection at start of content
                        if (!selection.empty || $from.parentOffset !== 0) return false
                        
                        const titleAncestor = findAncestor($from, 'taskCardTitle')
                        if (!titleAncestor) return false
                        
                        const taskCardDepth = titleAncestor.depth - 1
                        const taskCard = $from.node(taskCardDepth)
                        
                        // Only handle if task is empty
                        if (!isTaskCardEmpty(taskCard)) return false
                        
                        const listAncestor = findAncestor($from, 'taskCardList')
                        if (!listAncestor) return false
                        
                        const { node: list, depth: listDepth } = listAncestor
                        const listEnd = $from.after(listDepth)
                        
                        if (list.childCount === 1) {
                            // Only task - replace list with paragraph
                            const listStart = $from.before(listDepth)
                            return editor.chain()
                                .deleteRange({ from: listStart, to: listEnd })
                                .insertContentAt(listStart, { type: 'paragraph' })
                                .setTextSelection(listStart + 1)
                                .run()
                        } else {
                            // Delete just this task and insert paragraph after list
                            const taskStart = $from.before(taskCardDepth)
                            const taskEnd = $from.after(taskCardDepth)
                            return editor.chain()
                                .deleteRange({ from: taskStart, to: taskEnd })
                                .insertContentAt(listEnd - (taskEnd - taskStart), { type: 'paragraph' })
                                .setTextSelection(listEnd - (taskEnd - taskStart) + 1)
                                .run()
                        }
                    }
                }
            },
            
            // Custom node view for interactive checkbox
            addNodeView() {
                return ({ node, getPos, editor }) => {
                    const dom = document.createElement('div')
                    dom.className = `task-card ${node.attrs.checked ? 'is-completed' : ''}`
                    dom.setAttribute('data-type', 'task-card')
                    
                    // Checkbox
                    const checkbox = document.createElement('div')
                    checkbox.className = 'task-card-checkbox'
                    checkbox.setAttribute('contenteditable', 'false')
                    
                    checkbox.addEventListener('mousedown', (e) => {
                        e.preventDefault()
                        e.stopPropagation()
                        
                        const pos = getPos()
                        if (typeof pos === 'number') {
                            const currentNode = editor.state.doc.nodeAt(pos)
                            if (currentNode && currentNode.type.name === 'taskCard') {
                                editor.view.dispatch(
                                    editor.state.tr.setNodeMarkup(pos, undefined, {
                                        ...currentNode.attrs,
                                        checked: !currentNode.attrs.checked
                                    })
                                )
                            }
                        }
                    })
                    
                    // Content area (managed by TipTap)
                    const content = document.createElement('div')
                    content.className = 'task-card-content'
                    
                    dom.appendChild(checkbox)
                    dom.appendChild(content)
                    
                    return {
                        dom,
                        contentDOM: content,
                        update: (updatedNode) => {
                            if (updatedNode.type.name !== 'taskCard') return false
                            dom.className = `task-card ${updatedNode.attrs.checked ? 'is-completed' : ''}`
                            return true
                        }
                    }
                }
            }
        })
        
        // TaskCardTitle
        const TaskCardTitle = Node.create({
            name: 'taskCardTitle',
            group: 'block',
            content: 'inline*',
            defining: true,
            
            parseHTML() {
                return [{ tag: 'div[data-type="task-card-title"]' }]
            },
            
            renderHTML({ HTMLAttributes }) {
                return ['div', mergeAttributes(HTMLAttributes, { 
                    'data-type': 'task-card-title',
                    'class': 'task-card-title',
                    'data-placeholder': 'What needs to be done?'
                }), 0]
            }
        })
        
        // TaskCardDescription
        const TaskCardDescription = Node.create({
            name: 'taskCardDescription',
            group: 'block',
            content: 'inline*',
            
            parseHTML() {
                return [{ tag: 'div[data-type="task-card-description"]' }]
            },
            
            renderHTML({ HTMLAttributes }) {
                return ['div', mergeAttributes(HTMLAttributes, { 
                    'data-type': 'task-card-description',
                    'class': 'task-card-description',
                    'data-placeholder': 'Press Tab for description'
                }), 0]
            }
        })
        
        // ============================================
        // Prompt Snippet Nodes
        // ============================================
        
        // Helper: Create a new empty prompt snippet node
        function createPromptSnippet(schema) {
            const title = schema.nodes.promptSnippetTitle.create()
            const body = schema.nodes.promptSnippetBody.create()
            return schema.nodes.promptSnippet.create({ expanded: true }, [title, body])
        }
        
        // PromptSnippetList Node
        const PromptSnippetList = Node.create({
            name: 'promptSnippetList',
            group: 'block',
            content: 'promptSnippet+',
            
            parseHTML() {
                return [{ tag: 'div[data-type="prompt-snippet-list"]' }]
            },
            
            renderHTML({ HTMLAttributes }) {
                return ['div', mergeAttributes(HTMLAttributes, { 
                    'data-type': 'prompt-snippet-list',
                    'class': 'prompt-snippet-list'
                }), 0]
            }
        })
        
        // Helper: Check if a prompt snippet is empty (no text in title or body)
        function isPromptSnippetEmpty(snippet) {
            let empty = true
            snippet.forEach(child => {
                if (child.textContent.length > 0) empty = false
            })
            return empty
        }
        
        // PromptSnippet Node
        const PromptSnippet = Node.create({
            name: 'promptSnippet',
            group: 'block',
            content: 'promptSnippetTitle promptSnippetBody',
            defining: true,
            
            addAttributes() {
                return {
                    expanded: {
                        default: true,
                        parseHTML: el => el.getAttribute('data-expanded') !== 'false',
                        renderHTML: attrs => ({ 'data-expanded': attrs.expanded ? 'true' : 'false' })
                    },
                    completed: {
                        default: false,
                        parseHTML: el => el.getAttribute('data-completed') === 'true',
                        renderHTML: attrs => ({ 'data-completed': attrs.completed ? 'true' : 'false' })
                    }
                }
            },
            
            parseHTML() {
                return [{ tag: 'div[data-type="prompt-snippet"]' }]
            },
            
            renderHTML({ node, HTMLAttributes }) {
                const classes = ['prompt-snippet']
                if (!node.attrs.expanded) classes.push('is-collapsed')
                if (node.attrs.completed) classes.push('is-completed')
                return ['div', mergeAttributes(HTMLAttributes, { 
                    'data-type': 'prompt-snippet',
                    'class': classes.join(' ')
                }), 0]
            },
            
            addCommands() {
                return {
                    // Insert a new prompt snippet (or list with snippet if not in one)
                    insertPromptSnippet: () => ({ chain, state, editor }) => {
                        const { schema, selection: { $from } } = state
                        const snippet = createPromptSnippet(schema)
                        
                        // If already in a prompt snippet list, insert after current snippet
                        if (editor.isActive('promptSnippetList')) {
                            const ancestor = findAncestor($from, 'promptSnippet')
                            if (ancestor) {
                                const insertPos = $from.after(ancestor.depth)
                                return chain()
                                    .insertContentAt(insertPos, snippet.toJSON())
                                    .setTextSelection(insertPos + 2)
                                    .run()
                            }
                        }
                        
                        // Create new list - replace current block
                        const blockStart = $from.before($from.depth)
                        const blockEnd = $from.after($from.depth)
                        const snippetList = schema.nodes.promptSnippetList.create(null, [snippet])
                        
                        return chain()
                            .deleteRange({ from: blockStart, to: blockEnd })
                            .insertContentAt(blockStart, snippetList.toJSON())
                            .setTextSelection(blockStart + 3)
                            .run()
                    },
                    
                    // Toggle expanded/collapsed state of current prompt snippet
                    togglePromptSnippetExpanded: () => ({ tr, state, dispatch, editor }) => {
                        const ancestor = findAncestor(state.selection.$from, 'promptSnippet')
                        if (!ancestor) return false
                        
                        if (dispatch) {
                            const pos = state.selection.$from.before(ancestor.depth)
                            const newExpanded = !ancestor.node.attrs.expanded
                            
                            tr.setNodeMarkup(pos, undefined, {
                                ...ancestor.node.attrs,
                                expanded: newExpanded
                            })
                            
                            // If collapsing, move cursor out of the snippet
                            if (!newExpanded) {
                                const afterSnippet = state.selection.$from.after(ancestor.depth)
                                tr.setSelection(state.selection.constructor.near(tr.doc.resolve(afterSnippet)))
                            }
                            
                            dispatch(tr)
                        }
                        return true
                    },
                    
                    // Copy prompt snippet content to clipboard
                    copyPromptSnippet: () => ({ state }) => {
                        const ancestor = findAncestor(state.selection.$from, 'promptSnippet')
                        if (!ancestor) return false
                        
                        // Get text content from the body only
                        let bodyText = ''
                        ancestor.node.forEach(child => {
                            if (child.type.name === 'promptSnippetBody') {
                                bodyText = child.textContent
                            }
                        })
                        
                        if (bodyText) {
                            navigator.clipboard.writeText(bodyText)
                        }
                        return true
                    },
                    
                    // Expand a specific prompt snippet by position
                    expandPromptSnippetAt: (pos) => ({ tr, state, dispatch }) => {
                        const node = state.doc.nodeAt(pos)
                        if (!node || node.type.name !== 'promptSnippet') return false
                        
                        if (dispatch) {
                            tr.setNodeMarkup(pos, undefined, {
                                ...node.attrs,
                                expanded: true
                            })
                            // Position cursor in the title
                            tr.setSelection(state.selection.constructor.near(tr.doc.resolve(pos + 2)))
                            dispatch(tr)
                        }
                        return true
                    },
                    
                    // Toggle completed state of a prompt snippet at position
                    togglePromptSnippetCompleted: (pos) => ({ tr, state, dispatch }) => {
                        const node = state.doc.nodeAt(pos)
                        if (!node || node.type.name !== 'promptSnippet') return false
                        
                        if (dispatch) {
                            tr.setNodeMarkup(pos, undefined, {
                                ...node.attrs,
                                completed: !node.attrs.completed
                            })
                            dispatch(tr)
                        }
                        return true
                    }
                }
            },
            
            addKeyboardShortcuts() {
                return {
                    // Escape: exit empty snippet, or collapse if not empty
                    'Escape': ({ editor }) => {
                        if (!editor.isActive('promptSnippet')) return false
                        
                        const { $from } = editor.state.selection
                        const ancestor = findAncestor($from, 'promptSnippet')
                        if (!ancestor) return false
                        
                        // If snippet is empty, exit it
                        if (isPromptSnippetEmpty(ancestor.node)) {
                            const listAncestor = findAncestor($from, 'promptSnippetList')
                            if (!listAncestor) return false
                            
                            const { node: list, depth: listDepth } = listAncestor
                            const listStart = $from.before(listDepth)
                            const listEnd = $from.after(listDepth)
                            const snippetStart = $from.before(ancestor.depth)
                            const snippetEnd = $from.after(ancestor.depth)
                            
                            if (list.childCount === 1) {
                                return editor.chain()
                                    .deleteRange({ from: listStart, to: listEnd })
                                    .insertContentAt(listStart, { type: 'paragraph' })
                                    .setTextSelection(listStart + 1)
                                    .run()
                            } else {
                                const snippetSize = snippetEnd - snippetStart
                                const newListEnd = listEnd - snippetSize
                                
                                return editor.chain()
                                    .deleteRange({ from: snippetStart, to: snippetEnd })
                                    .insertContentAt(newListEnd, { type: 'paragraph' })
                                    .setTextSelection(newListEnd + 1)
                                    .run()
                            }
                        }
                        
                        // Otherwise just collapse if expanded
                        if (!ancestor.node.attrs.expanded) return false
                        return editor.commands.togglePromptSnippetExpanded()
                    },
                    
                    // Enter: move to body from title, or collapse & new snippet from body
                    'Enter': ({ editor }) => {
                        if (!editor.isActive('promptSnippet')) return false
                        
                        const { state } = editor
                        const { $from } = state.selection
                        const snippetAncestor = findAncestor($from, 'promptSnippet')
                        if (!snippetAncestor) return false
                        
                        const { node: snippet, depth: snippetDepth } = snippetAncestor
                        
                        // If snippet is empty, exit snippet formatting
                        if (isPromptSnippetEmpty(snippet)) {
                            const listAncestor = findAncestor($from, 'promptSnippetList')
                            if (!listAncestor) return false
                            
                            const { node: list, depth: listDepth } = listAncestor
                            const listStart = $from.before(listDepth)
                            const listEnd = $from.after(listDepth)
                            
                            if (list.childCount === 1) {
                                // Only snippet in list - replace entire list with paragraph
                                return editor.chain()
                                    .deleteRange({ from: listStart, to: listEnd })
                                    .insertContentAt(listStart, { type: 'paragraph' })
                                    .setTextSelection(listStart + 1)
                                    .run()
                            } else {
                                // Multiple snippets - delete empty snippet and insert paragraph after list
                                const snippetStart = $from.before(snippetDepth)
                                const snippetEnd = $from.after(snippetDepth)
                                const snippetSize = snippetEnd - snippetStart
                                const newListEnd = listEnd - snippetSize
                                
                                return editor.chain()
                                    .deleteRange({ from: snippetStart, to: snippetEnd })
                                    .insertContentAt(newListEnd, { type: 'paragraph' })
                                    .setTextSelection(newListEnd + 1)
                                    .run()
                            }
                        }
                        
                        // Check if we're in title or body
                        const titleAncestor = findAncestor($from, 'promptSnippetTitle')
                        const bodyAncestor = findAncestor($from, 'promptSnippetBody')
                        
                        if (titleAncestor) {
                            // In title - move to body
                            const snippetStart = $from.before(snippetDepth)
                            let bodyPos = null
                            let offset = 1
                            snippet.forEach(child => {
                                if (child.type.name === 'promptSnippetTitle') {
                                    offset += child.nodeSize
                                } else if (child.type.name === 'promptSnippetBody') {
                                    bodyPos = snippetStart + offset + 1
                                }
                            })
                            
                            if (bodyPos) {
                                return editor.commands.setTextSelection(bodyPos)
                            }
                        } else if (bodyAncestor) {
                            // In body - collapse current snippet and create new one
                            const pos = $from.before(snippetDepth)
                            const insertPos = $from.after(snippetDepth)
                            
                            // Collapse current snippet
                            editor.view.dispatch(
                                editor.state.tr.setNodeMarkup(pos, undefined, {
                                    ...snippet.attrs,
                                    expanded: false
                                })
                            )
                            
                            // Insert new snippet after
                            return editor.chain()
                                .insertContentAt(insertPos, createPromptSnippet(state.schema).toJSON())
                                .setTextSelection(insertPos + 2)
                                .run()
                        }
                        
                        return false
                    },
                    
                    // Tab: move from title to body
                    'Tab': ({ editor }) => {
                        if (!editor.isActive('promptSnippet')) return false
                        
                        const { state } = editor
                        const { $from } = state.selection
                        const titleAncestor = findAncestor($from, 'promptSnippetTitle')
                        if (!titleAncestor) return false
                        
                        const snippetDepth = titleAncestor.depth - 1
                        const snippet = $from.node(snippetDepth)
                        const snippetStart = $from.before(snippetDepth)
                        
                        // Find body position
                        let bodyPos = null
                        let offset = 1
                        snippet.forEach(child => {
                            if (child.type.name === 'promptSnippetTitle') {
                                offset += child.nodeSize
                            } else if (child.type.name === 'promptSnippetBody') {
                                bodyPos = snippetStart + offset + 1
                            }
                        })
                        
                        if (bodyPos) {
                            return editor.commands.setTextSelection(bodyPos)
                        }
                        return false
                    },
                    
                    // Shift+Tab: move from body to title
                    'Shift-Tab': ({ editor }) => {
                        if (!editor.isActive('promptSnippet')) return false
                        
                        const { $from } = editor.state.selection
                        const bodyAncestor = findAncestor($from, 'promptSnippetBody')
                        if (!bodyAncestor) return false
                        
                        const snippetStart = $from.before(bodyAncestor.depth - 1)
                        return editor.commands.setTextSelection(snippetStart + 2)
                    },
                    
                    // Backspace at start of empty title: exit snippet formatting
                    'Backspace': ({ editor }) => {
                        if (!editor.isActive('promptSnippet')) return false
                        
                        const { selection, selection: { $from } } = editor.state
                        
                        // Only handle empty selection at start of content
                        if (!selection.empty || $from.parentOffset !== 0) return false
                        
                        const titleAncestor = findAncestor($from, 'promptSnippetTitle')
                        if (!titleAncestor) return false
                        
                        const snippetDepth = titleAncestor.depth - 1
                        const snippet = $from.node(snippetDepth)
                        
                        // Only handle if snippet is empty
                        if (!isPromptSnippetEmpty(snippet)) return false
                        
                        const listAncestor = findAncestor($from, 'promptSnippetList')
                        if (!listAncestor) return false
                        
                        const { node: list, depth: listDepth } = listAncestor
                        const listStart = $from.before(listDepth)
                        const listEnd = $from.after(listDepth)
                        
                        if (list.childCount === 1) {
                            // Only snippet - replace list with paragraph
                            return editor.chain()
                                .deleteRange({ from: listStart, to: listEnd })
                                .insertContentAt(listStart, { type: 'paragraph' })
                                .setTextSelection(listStart + 1)
                                .run()
                        } else {
                            // Multiple snippets - delete empty snippet and insert paragraph after list
                            const snippetStart = $from.before(snippetDepth)
                            const snippetEnd = $from.after(snippetDepth)
                            const snippetSize = snippetEnd - snippetStart
                            const newListEnd = listEnd - snippetSize
                            
                            return editor.chain()
                                .deleteRange({ from: snippetStart, to: snippetEnd })
                                .insertContentAt(newListEnd, { type: 'paragraph' })
                                .setTextSelection(newListEnd + 1)
                                .run()
                        }
                    },
                    
                    // Delete key - same behavior as Backspace for empty snippets
                    'Delete': ({ editor }) => {
                        if (!editor.isActive('promptSnippet')) return false
                        
                        const { selection, selection: { $from } } = editor.state
                        const titleAncestor = findAncestor($from, 'promptSnippetTitle')
                        if (!titleAncestor) return false
                        
                        const snippetDepth = titleAncestor.depth - 1
                        const snippet = $from.node(snippetDepth)
                        
                        // Only handle if snippet is empty
                        if (!isPromptSnippetEmpty(snippet)) return false
                        
                        const listAncestor = findAncestor($from, 'promptSnippetList')
                        if (!listAncestor) return false
                        
                        const { node: list, depth: listDepth } = listAncestor
                        const listStart = $from.before(listDepth)
                        const listEnd = $from.after(listDepth)
                        
                        if (list.childCount === 1) {
                            // Only snippet - replace list with paragraph
                            return editor.chain()
                                .deleteRange({ from: listStart, to: listEnd })
                                .insertContentAt(listStart, { type: 'paragraph' })
                                .setTextSelection(listStart + 1)
                                .run()
                        } else {
                            // Multiple snippets - delete empty snippet and insert paragraph after list
                            const snippetStart = $from.before(snippetDepth)
                            const snippetEnd = $from.after(snippetDepth)
                            const snippetSize = snippetEnd - snippetStart
                            const newListEnd = listEnd - snippetSize
                            
                            return editor.chain()
                                .deleteRange({ from: snippetStart, to: snippetEnd })
                                .insertContentAt(newListEnd, { type: 'paragraph' })
                                .setTextSelection(newListEnd + 1)
                                .run()
                        }
                    },
                    
                    // Mod+Enter: quick collapse
                    'Mod-Enter': ({ editor }) => {
                        if (!editor.isActive('promptSnippet')) return false
                        return editor.commands.togglePromptSnippetExpanded()
                    }
                }
            },
            
            // Custom node view for interactive collapsed/expanded states
            addNodeView() {
                return ({ node, getPos, editor }) => {
                    const dom = document.createElement('div')
                    
                    function getClassName(n) {
                        const classes = ['prompt-snippet']
                        if (!n.attrs.expanded) classes.push('is-collapsed')
                        if (n.attrs.completed) classes.push('is-completed')
                        return classes.join(' ')
                    }
                    
                    dom.className = getClassName(node)
                    dom.setAttribute('data-type', 'prompt-snippet')
                    
                    // Helper to delete this snippet
                    function deleteSnippet() {
                        const pos = getPos()
                        if (typeof pos === 'number') {
                            const currentNode = editor.state.doc.nodeAt(pos)
                            if (currentNode) {
                                editor.chain()
                                    .deleteRange({ from: pos, to: pos + currentNode.nodeSize })
                                    .run()
                            }
                        }
                    }
                    
                    // Checkbox (toggles completed state, like task card)
                    const checkbox = document.createElement('div')
                    checkbox.className = 'prompt-snippet-checkbox'
                    checkbox.setAttribute('contenteditable', 'false')
                    
                    checkbox.addEventListener('mousedown', (e) => {
                        e.preventDefault()
                        e.stopPropagation()
                        const pos = getPos()
                        if (typeof pos === 'number') {
                            editor.commands.togglePromptSnippetCompleted(pos)
                        }
                    })
                    
                    // Content area (managed by TipTap)
                    const content = document.createElement('div')
                    content.className = 'prompt-snippet-content'
                    
                    // Preview area (shown when collapsed)
                    const preview = document.createElement('div')
                    preview.className = 'prompt-snippet-preview'
                    
                    // Copy feedback toast
                    const feedback = document.createElement('div')
                    feedback.className = 'prompt-snippet-copy-feedback'
                    feedback.textContent = 'Copied!'
                    
                    // Helper to create button with icon
                    function createButton(iconHtml, label, className = '') {
                        const btn = document.createElement('button')
                        btn.className = `prompt-snippet-action ${className}`.trim()
                        btn.type = 'button'
                        btn.innerHTML = `<span class="prompt-snippet-action-icon">${iconHtml}</span>${label}`
                        return btn
                    }
                    
                    // Actions container (positioned absolutely in top right)
                    const actions = document.createElement('div')
                    actions.className = 'prompt-snippet-actions'
                    actions.setAttribute('contenteditable', 'false')
                    
                    const doneBtn = createButton('✓', 'Done', 'prompt-snippet-action--done')
                    const copyBtn = createButton('⧉', 'Copy')
                    const deleteBtn = createButton('×', 'Delete', 'prompt-snippet-action--delete')
                    
                    doneBtn.addEventListener('mousedown', (e) => {
                        e.preventDefault()
                        e.stopPropagation()
                        const pos = getPos()
                        if (typeof pos === 'number') {
                            const currentNode = editor.state.doc.nodeAt(pos)
                            if (currentNode && currentNode.type.name === 'promptSnippet') {
                                editor.view.dispatch(
                                    editor.state.tr.setNodeMarkup(pos, undefined, {
                                        ...currentNode.attrs,
                                        expanded: false
                                    })
                                )
                            }
                        }
                    })
                    
                    copyBtn.addEventListener('mousedown', (e) => {
                        e.preventDefault()
                        e.stopPropagation()
                        const pos = getPos()
                        if (typeof pos === 'number') {
                            const currentNode = editor.state.doc.nodeAt(pos)
                            if (currentNode && currentNode.type.name === 'promptSnippet') {
                                let bodyText = ''
                                currentNode.forEach(child => {
                                    if (child.type.name === 'promptSnippetBody') {
                                        bodyText = child.textContent
                                    }
                                })
                                if (bodyText) {
                                    navigator.clipboard.writeText(bodyText)
                                    feedback.classList.add('visible')
                                    setTimeout(() => feedback.classList.remove('visible'), 1500)
                                }
                            }
                        }
                    })
                    
                    deleteBtn.addEventListener('mousedown', (e) => {
                        e.preventDefault()
                        e.stopPropagation()
                        deleteSnippet()
                    })
                    
                    actions.appendChild(doneBtn)
                    actions.appendChild(copyBtn)
                    actions.appendChild(deleteBtn)
                    
                    // Right-click context menu for delete
                    dom.addEventListener('contextmenu', (e) => {
                        e.preventDefault()
                        e.stopPropagation()
                        
                        // Remove any existing context menu
                        const existingMenu = document.querySelector('.prompt-snippet-context-menu')
                        if (existingMenu) existingMenu.remove()
                        
                        const menu = document.createElement('div')
                        menu.className = 'prompt-snippet-context-menu'
                        menu.style.cssText = `
                            position: fixed;
                            left: ${e.clientX}px;
                            top: ${e.clientY}px;
                            background: var(--writa-card-bg, #fff);
                            border: 1px solid var(--writa-border-color, rgba(128,128,128,0.2));
                            border-radius: 8px;
                            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
                            padding: 4px;
                            z-index: 1000;
                        `
                        
                        const deleteOption = document.createElement('button')
                        deleteOption.style.cssText = `
                            display: block;
                            width: 100%;
                            padding: 8px 16px;
                            border: none;
                            background: transparent;
                            color: #FF3B30;
                            font-size: 13px;
                            text-align: left;
                            cursor: pointer;
                            border-radius: 4px;
                        `
                        deleteOption.textContent = 'Delete Snippet'
                        deleteOption.addEventListener('mouseenter', () => {
                            deleteOption.style.background = 'rgba(255,59,48,0.1)'
                        })
                        deleteOption.addEventListener('mouseleave', () => {
                            deleteOption.style.background = 'transparent'
                        })
                        deleteOption.addEventListener('click', () => {
                            menu.remove()
                            deleteSnippet()
                        })
                        
                        menu.appendChild(deleteOption)
                        document.body.appendChild(menu)
                        
                        // Close menu on click outside
                        const closeMenu = (evt) => {
                            if (!menu.contains(evt.target)) {
                                menu.remove()
                                document.removeEventListener('mousedown', closeMenu)
                            }
                        }
                        setTimeout(() => document.addEventListener('mousedown', closeMenu), 0)
                    })
                    
                    // Preview actions (for collapsed state)
                    const previewActions = document.createElement('div')
                    previewActions.className = 'prompt-snippet-preview-actions'
                    previewActions.setAttribute('contenteditable', 'false')
                    
                    const editBtn = createButton('✎', 'Edit')
                    const previewCopyBtn = createButton('⧉', 'Copy')
                    
                    editBtn.addEventListener('mousedown', (e) => {
                        e.preventDefault()
                        e.stopPropagation()
                        const pos = getPos()
                        if (typeof pos === 'number') {
                            editor.commands.expandPromptSnippetAt(pos)
                        }
                    })
                    
                    previewCopyBtn.addEventListener('mousedown', (e) => {
                        e.preventDefault()
                        e.stopPropagation()
                        const pos = getPos()
                        if (typeof pos === 'number') {
                            const currentNode = editor.state.doc.nodeAt(pos)
                            if (currentNode && currentNode.type.name === 'promptSnippet') {
                                let bodyText = ''
                                currentNode.forEach(child => {
                                    if (child.type.name === 'promptSnippetBody') {
                                        bodyText = child.textContent
                                    }
                                })
                                if (bodyText) {
                                    navigator.clipboard.writeText(bodyText)
                                    feedback.classList.add('visible')
                                    setTimeout(() => feedback.classList.remove('visible'), 1500)
                                }
                            }
                        }
                    })
                    
                    previewActions.appendChild(editBtn)
                    previewActions.appendChild(previewCopyBtn)
                    
                    // Click handler for collapsed state - copy to clipboard
                    dom.addEventListener('click', (e) => {
                        const pos = getPos()
                        if (typeof pos !== 'number') return
                        
                        const currentNode = editor.state.doc.nodeAt(pos)
                        if (!currentNode || currentNode.type.name !== 'promptSnippet') return
                        
                        // Only handle clicks when collapsed and not on buttons
                        if (!currentNode.attrs.expanded && !e.target.closest('.prompt-snippet-action')) {
                            e.preventDefault()
                            e.stopPropagation()
                            
                            let bodyText = ''
                            currentNode.forEach(child => {
                                if (child.type.name === 'promptSnippetBody') {
                                    bodyText = child.textContent
                                }
                            })
                            
                            if (bodyText) {
                                navigator.clipboard.writeText(bodyText)
                                feedback.classList.add('visible')
                                setTimeout(() => feedback.classList.remove('visible'), 1500)
                            }
                        }
                    })
                    
                    // Mousedown handler to prevent cursor placement in collapsed state
                    dom.addEventListener('mousedown', (e) => {
                        const pos = getPos()
                        if (typeof pos !== 'number') return
                        
                        const currentNode = editor.state.doc.nodeAt(pos)
                        if (!currentNode || currentNode.type.name !== 'promptSnippet') return
                        
                        // Prevent cursor placement when collapsed (except on action buttons)
                        if (!currentNode.attrs.expanded && !e.target.closest('.prompt-snippet-action')) {
                            e.preventDefault()
                            e.stopPropagation()
                        }
                    })
                    
                    // Build preview content
                    function updatePreview(snippetNode) {
                        let titleText = ''
                        let bodyText = ''
                        snippetNode.forEach(child => {
                            if (child.type.name === 'promptSnippetTitle') {
                                titleText = child.textContent
                            } else if (child.type.name === 'promptSnippetBody') {
                                bodyText = child.textContent
                            }
                        })
                        
                        preview.innerHTML = ''
                        
                        const previewTitle = document.createElement('div')
                        previewTitle.className = 'prompt-snippet-preview-title'
                        previewTitle.textContent = titleText || 'Untitled Snippet'
                        
                        const previewBody = document.createElement('div')
                        previewBody.className = 'prompt-snippet-preview-body'
                        previewBody.textContent = bodyText.length > 150 
                            ? bodyText.substring(0, 150) + '...' 
                            : bodyText || 'Empty snippet'
                        
                        preview.appendChild(previewTitle)
                        preview.appendChild(previewBody)
                    }
                    
                    updatePreview(node)
                    
                    dom.appendChild(checkbox)
                    dom.appendChild(content)
                    dom.appendChild(preview)
                    dom.appendChild(actions)
                    dom.appendChild(previewActions)
                    dom.appendChild(feedback)
                    
                    return {
                        dom,
                        contentDOM: content,
                        update: (updatedNode) => {
                            if (updatedNode.type.name !== 'promptSnippet') return false
                            
                            dom.className = getClassName(updatedNode)
                            
                            updatePreview(updatedNode)
                            
                            return true
                        }
                    }
                }
            }
        })
        
        // PromptSnippetTitle
        const PromptSnippetTitle = Node.create({
            name: 'promptSnippetTitle',
            group: 'block',
            content: 'inline*',
            defining: true,
            
            parseHTML() {
                return [{ tag: 'div[data-type="prompt-snippet-title"]' }]
            },
            
            renderHTML({ HTMLAttributes }) {
                return ['div', mergeAttributes(HTMLAttributes, { 
                    'data-type': 'prompt-snippet-title',
                    'class': 'prompt-snippet-title'
                }), 0]
            }
        })
        
        // PromptSnippetBody
        const PromptSnippetBody = Node.create({
            name: 'promptSnippetBody',
            group: 'block',
            content: 'inline*',
            
            parseHTML() {
                return [{ tag: 'div[data-type="prompt-snippet-body"]' }]
            },
            
            renderHTML({ HTMLAttributes }) {
                return ['div', mergeAttributes(HTMLAttributes, { 
                    'data-type': 'prompt-snippet-body',
                    'class': 'prompt-snippet-body'
                }), 0]
            }
        })
        
        // ============================================
        // Editor Setup
        // ============================================
        
        function sendToSwift(msg) {
            if (window.webkit?.messageHandlers?.tiptap) {
                window.webkit.messageHandlers.tiptap.postMessage(msg);
            }
        }
        
        function getState() {
            if (!window.editor) return {};
            var e = window.editor;
            return {
                isBold: e.isActive('bold'),
                isItalic: e.isActive('italic'),
                isUnderline: e.isActive('underline'),
                isStrike: e.isActive('strike'),
                isCode: e.isActive('code'),
                isCodeBlock: e.isActive('codeBlock'),
                isBlockquote: e.isActive('blockquote'),
                isBulletList: e.isActive('bulletList'),
                isOrderedList: e.isActive('orderedList'),
                isTaskList: e.isActive('taskList'),
                isTaskCard: e.isActive('taskCard'),
                isPromptSnippet: e.isActive('promptSnippet'),
                isHighlight: (() => {
                    // Use TipTap's built-in isActive for marks - it handles cursor position correctly
                    return e.isActive('highlight');
                })(),
                highlightColor: (() => {
                    const { state } = editor;
                    const { $from, $to } = state.selection;
                    let color = '#fef08a'; // Default yellow
                    
                    // Get marks at the start of selection
                    const marks = $from.marks();
                    const highlightMark = marks.find(mark => mark.type.name === 'highlight');
                    if (highlightMark && highlightMark.attrs.color) {
                        color = highlightMark.attrs.color;
                    } else {
                        // Fallback: check nodes in selection
                        state.doc.nodesBetween($from.pos, $to.pos, (node) => {
                            if (node.marks) {
                                const mark = node.marks.find(m => m.type.name === 'highlight');
                                if (mark && mark.attrs.color) {
                                    color = mark.attrs.color;
                                    return false; // Stop searching
                                }
                            }
                        });
                    }
                    
                    return color;
                })(),
                isSubscript: e.isActive('subscript'),
                isSuperscript: e.isActive('superscript'),
                headingLevel: e.isActive('heading', { level: 1 }) ? 1 : 
                              e.isActive('heading', { level: 2 }) ? 2 : 
                              e.isActive('heading', { level: 3 }) ? 3 : 0,
                isLink: e.isActive('link'),
                textAlign: e.isActive({ textAlign: 'left' }) ? 'left' :
                          e.isActive({ textAlign: 'center' }) ? 'center' :
                          e.isActive({ textAlign: 'right' }) ? 'right' :
                          e.isActive({ textAlign: 'justify' }) ? 'justify' : 'left',
                canUndo: e.can().undo(),
                canRedo: e.can().redo()
            };
        }
        
        // Track previous task card to clean up empty descriptions when leaving
        let previousTaskCardPos = null;
        function cleanupEmptyDescriptions(editor) {
            const { state } = editor;
            const { doc, schema } = state;
            
            // Find all task cards with empty descriptions and remove them
            const changes = [];
            doc.descendants((node, pos) => {
                if (node.type.name === 'taskCard') {
                    node.forEach((child, offset) => {
                        if (child.type.name === 'taskCardDescription' && child.textContent === '') {
                            // Calculate absolute position of description
                            const descStart = pos + 1 + offset;
                            const descEnd = descStart + child.nodeSize;
                            changes.push({ from: descStart, to: descEnd });
                        }
                    });
                }
            });
            
            // Apply deletions in reverse order to preserve positions
            if (changes.length > 0) {
                let tr = state.tr;
                changes.reverse().forEach(({ from, to }) => {
                    tr = tr.delete(from, to);
                });
                editor.view.dispatch(tr);
            }
        }
        
        function onSelectionChange(editor) {
            const { state } = editor;
            const { $from } = state.selection;
            
            // Find current task card position using ProseMirror state
            let currentTaskCardPos = null;
            for (let d = $from.depth; d > 0; d--) {
                if ($from.node(d).type.name === 'taskCard') {
                    currentTaskCardPos = $from.before(d);
                    break;
                }
            }
            
            // Position and show/hide floating action bar
            const actionBar = document.getElementById('task-action-bar');
            if (actionBar) {
                if (currentTaskCardPos !== null) {
                    // Find the DOM element for the focused task card
                    const sel = window.getSelection();
                    if (sel && sel.anchorNode) {
                        // Use numeric constant (1) instead of Node.ELEMENT_NODE to avoid conflict with TipTap's Node import
                        const focusedCard = sel.anchorNode.nodeType === 1 
                            ? sel.anchorNode.closest('.task-card')
                            : sel.anchorNode.parentElement?.closest('.task-card');
                        if (focusedCard) {
                            // Position using fixed positioning (viewport-relative)
                            // getBoundingClientRect() returns viewport coordinates, which matches position: fixed
                            const cardRect = focusedCard.getBoundingClientRect();
                            
                            actionBar.style.top = (cardRect.bottom - 20) + 'px';
                            actionBar.style.right = (window.innerWidth - cardRect.right + 12) + 'px';
                            actionBar.classList.add('visible');
                            
                            // Store the current task card position for button actions
                            actionBar.dataset.taskCardPos = currentTaskCardPos;
                        } else {
                            actionBar.classList.remove('visible');
                        }
                    } else {
                        actionBar.classList.remove('visible');
                    }
                } else {
                    actionBar.classList.remove('visible');
                }
            }
            
            // If we left a task card, clean up its empty description
            if (previousTaskCardPos !== null && previousTaskCardPos !== currentTaskCardPos) {
                // Delay cleanup to avoid interfering with current operation
                setTimeout(() => cleanupEmptyDescriptions(editor), 10);
            }
            
            previousTaskCardPos = currentTaskCardPos;
        }
        
        try {
            sendToSwift({ type: 'debug', message: 'Starting editor initialization...' });
            
            const editor = new Editor({
                element: document.getElementById('editor'),
                extensions: [
                    StarterKit.configure({
                        heading: { levels: [1, 2, 3] }
                    }),
                    Placeholder.configure({ 
                        placeholder: ({ node }) => {
                            if (node.type.name === 'taskCardTitle') return 'What needs to be done?'
                            if (node.type.name === 'taskCardDescription') return 'Add notes...'
                            if (node.type.name === 'promptSnippetTitle') return 'Snippet title...'
                            if (node.type.name === 'promptSnippetBody') return 'Write your prompt here...'
                            return 'Start writing...'
                        },
                        includeChildren: true,
                        showOnlyCurrent: false
                    }),
                    Underline,
                    Link.configure({
                        openOnClick: false,
                        HTMLAttributes: { class: 'link' }
                    }),
                    TaskList,
                    TaskItem.configure({ nested: true }),
                    TaskCardList,
                    TaskCard,
                    TaskCardTitle,
                    TaskCardDescription,
                    PromptSnippetList,
                    PromptSnippet,
                    PromptSnippetTitle,
                    PromptSnippetBody,
                    Image.configure({
                        HTMLAttributes: { class: 'image' }
                    }),
                    Table.configure({ resizable: true }),
                    TableRow,
                    TableHeader,
                    TableCell,
                    Highlight.configure({ multicolor: true }),
                    TextAlign.configure({ types: ['heading', 'paragraph'] }),
                    Subscript,
                    Superscript,
                    TextStyle,
                    Color
                ],
                content: '<h1></h1>',
                onUpdate: ({ editor }) => {
                    sendToSwift({
                        type: 'contentChange',
                        html: editor.getHTML(),
                        json: JSON.stringify(editor.getJSON()),
                        text: editor.getText()
                    });
                },
                onSelectionUpdate: ({ editor }) => {
                    sendToSwift({ type: 'selectionChange', state: getState() });
                    onSelectionChange(editor);
                }
            });
            
            window.editor = editor;
            
            window.editorBridge = {
                setContent: (html) => {
                    editor.commands.setContent(html || '<h1></h1>');
                },
                setContentJSON: (jsonStr) => { 
                    if (jsonStr) {
                        try {
                            const json = typeof jsonStr === 'string' ? JSON.parse(jsonStr) : jsonStr;
                            editor.commands.setContent(json);
                        } catch (e) {
                            console.error('Failed to parse JSON content:', e);
                        }
                    }
                },
                getContent: () => editor.getHTML(),
                getContentJSON: () => JSON.stringify(editor.getJSON()),
                getText: () => editor.getText(),
                
                toggleBold: () => editor.chain().focus().toggleBold().run(),
                toggleItalic: () => editor.chain().focus().toggleItalic().run(),
                toggleUnderline: () => editor.chain().focus().toggleUnderline().run(),
                toggleStrike: () => editor.chain().focus().toggleStrike().run(),
                toggleCode: () => editor.chain().focus().toggleCode().run(),
                toggleHighlight: () => editor.chain().focus().toggleHighlight().run(),
                setHighlightColor: (color) => editor.chain().focus().toggleHighlight({ color }).run(),
                getHighlightColor: () => {
                    const { state } = editor;
                    const { from, to } = state.selection;
                    let highlightColor = '#fef08a'; // Default yellow
                    
                    state.doc.nodesBetween(from, to, (node, pos) => {
                        if (node.marks) {
                            const highlightMark = node.marks.find(mark => mark.type.name === 'highlight');
                            if (highlightMark && highlightMark.attrs.color) {
                                highlightColor = highlightMark.attrs.color;
                            }
                        }
                    });
                    
                    return highlightColor;
                },
                toggleSubscript: () => editor.chain().focus().toggleSubscript().run(),
                toggleSuperscript: () => editor.chain().focus().toggleSuperscript().run(),
                
                setHeading: (level) => {
                    if (level === 0) editor.chain().focus().setParagraph().run();
                    else editor.chain().focus().toggleHeading({ level }).run();
                },
                toggleHeading1: () => editor.chain().focus().toggleHeading({ level: 1 }).run(),
                toggleHeading2: () => editor.chain().focus().toggleHeading({ level: 2 }).run(),
                toggleHeading3: () => editor.chain().focus().toggleHeading({ level: 3 }).run(),
                
                toggleBulletList: () => editor.chain().focus().toggleBulletList().run(),
                toggleOrderedList: () => editor.chain().focus().toggleOrderedList().run(),
                toggleTaskList: () => editor.chain().focus().toggleTaskList().run(),
                
                toggleTaskCard: () => editor.commands.insertTaskCard(),
                insertTaskCard: () => editor.commands.insertTaskCard(),
                toggleTaskCardChecked: () => editor.commands.toggleTaskCardChecked(),
                
                // Prompt Snippet commands
                insertPromptSnippet: () => editor.commands.insertPromptSnippet(),
                togglePromptSnippet: () => editor.commands.insertPromptSnippet(),
                togglePromptSnippetExpanded: () => editor.commands.togglePromptSnippetExpanded(),
                copyPromptSnippet: () => editor.commands.copyPromptSnippet(),
                
                // Set a specific task's checked state by node index (for sync from Tasks view)
                setTaskChecked: (nodeIndex, checked) => {
                    const { doc, tr } = editor.state;
                    let currentIndex = 0;
                    let found = false;
                    
                    doc.descendants((node, pos) => {
                        if (found) return false;  // Stop traversal once found
                        if (node.type.name === 'taskCard') {
                            if (currentIndex === nodeIndex) {
                                // Found the task - update its checked attribute
                                tr.setNodeMarkup(pos, undefined, {
                                    ...node.attrs,
                                    checked: checked
                                });
                                found = true;
                                return false;
                            }
                            currentIndex++;
                        }
                        return true;  // Continue traversal
                    });
                    
                    if (found) {
                        editor.view.dispatch(tr);
                        sendToSwift({ type: 'debug', message: `Task ${nodeIndex} set to checked=${checked}` });
                    } else {
                        sendToSwift({ type: 'debug', message: `Task ${nodeIndex} not found` });
                    }
                },
                
                toggleBlockquote: () => editor.chain().focus().toggleBlockquote().run(),
                toggleCodeBlock: () => editor.chain().focus().toggleCodeBlock().run(),
                setHorizontalRule: () => editor.chain().focus().setHorizontalRule().run(),
                
                setLink: (url) => {
                    if (url) editor.chain().focus().setLink({ href: url }).run();
                    else editor.chain().focus().unsetLink().run();
                },
                unsetLink: () => editor.chain().focus().unsetLink().run(),
                
                insertImage: (src, alt) => {
                    if (src) editor.chain().focus().setImage({ src, alt: alt || '' }).run();
                },
                
                insertTable: () => editor.chain().focus()
                    .insertTable({ rows: 3, cols: 3, withHeaderRow: true }).run(),
                deleteTable: () => editor.chain().focus().deleteTable().run(),
                addColumnBefore: () => editor.chain().focus().addColumnBefore().run(),
                addColumnAfter: () => editor.chain().focus().addColumnAfter().run(),
                deleteColumn: () => editor.chain().focus().deleteColumn().run(),
                addRowBefore: () => editor.chain().focus().addRowBefore().run(),
                addRowAfter: () => editor.chain().focus().addRowAfter().run(),
                deleteRow: () => editor.chain().focus().deleteRow().run(),
                toggleHeaderCell: () => editor.chain().focus().toggleHeaderCell().run(),
                mergeCells: () => editor.chain().focus().mergeCells().run(),
                splitCell: () => editor.chain().focus().splitCell().run(),
                
                setTextAlign: (align) => editor.chain().focus().setTextAlign(align).run(),
                setColor: (color) => editor.chain().focus().setColor(color).run(),
                unsetColor: () => editor.chain().focus().unsetColor().run(),
                
                undo: () => editor.chain().focus().undo().run(),
                redo: () => editor.chain().focus().redo().run(),
                
                focus: () => editor.commands.focus(),
                blur: () => editor.commands.blur(),
                getState: () => JSON.stringify(getState()),
                setThemeCSS: (css) => {
                    const el = document.getElementById('theme-styles');
                    if (el) el.textContent = css;
                }
            };
            
            editor.commands.focus();
            sendToSwift({ type: 'ready' });
            sendToSwift({ type: 'debug', message: 'Editor initialized successfully!' });
            
            // Update action bar position on scroll (required for position: fixed)
            const editorElement = document.getElementById('editor');
            if (editorElement) {
                editorElement.addEventListener('scroll', () => {
                    const actionBar = document.getElementById('task-action-bar');
                    if (actionBar && actionBar.classList.contains('visible')) {
                        onSelectionChange(editor);
                    }
                }, { passive: true });
            }
            
            // Set up floating action bar click handlers
            const actionBar = document.getElementById('task-action-bar');
            if (actionBar) {
                actionBar.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    const action = e.target.closest('[data-action]')?.dataset.action;
                    if (!action) return;
                    
                    const taskCardPos = parseInt(actionBar.dataset.taskCardPos, 10);
                    if (isNaN(taskCardPos)) return;
                    
                    if (action === 'new-task') {
                        editor.commands.insertTaskCard();
                    } else if (action === 'description') {
                        // Focus into the task card title first
                        editor.commands.setTextSelection(taskCardPos + 2);
                        setTimeout(() => {
                            const { state } = editor;
                            const { $from } = state.selection;
                            const taskCard = $from.node($from.depth - 1);
                            const taskCardStart = $from.before($from.depth - 1);
                            
                            let hasDescription = false;
                            let descPos = null;
                            let offset = 1;
                            if (taskCard) {
                                taskCard.forEach(child => {
                                    if (child.type.name === 'taskCardTitle') {
                                        offset += child.nodeSize;
                                    } else if (child.type.name === 'taskCardDescription') {
                                        hasDescription = true;
                                        descPos = taskCardStart + offset + 1;
                                    }
                                });
                            }
                            
                            if (hasDescription && descPos) {
                                editor.commands.setTextSelection(descPos);
                            } else {
                                const insertPos = $from.after($from.depth - 1) - 1;
                                const newDesc = state.schema.nodes.taskCardDescription.create();
                                editor.chain()
                                    .insertContentAt(insertPos, newDesc.toJSON())
                                    .setTextSelection(insertPos + 1)
                                    .run();
                            }
                        }, 10);
                    } else if (action === 'delete') {
                        const currentNode = editor.state.doc.nodeAt(taskCardPos);
                        if (currentNode) {
                            editor.chain().deleteRange({ from: taskCardPos, to: taskCardPos + currentNode.nodeSize }).run();
                        }
                    }
                });
            }
            
        } catch (err) {
            sendToSwift({ type: 'debug', message: 'ERROR: ' + err.message });
            sendToSwift({ type: 'debug', message: 'Stack: ' + err.stack });
        }
    </script>
</body>
</html>

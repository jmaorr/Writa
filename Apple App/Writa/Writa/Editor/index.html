<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <style id="base-styles">
        * { box-sizing: border-box; }
        html, body { 
            margin: 0; 
            padding: 0; 
            background: transparent;
            height: 100%;
            overflow: hidden;
        }
        #editor {
            height: 100%;
            overflow-y: auto;
        }
        .tiptap { outline: none; }
        .tiptap .selectedCell:after {
            z-index: 2;
            position: absolute;
            content: "";
            left: 0; right: 0; top: 0; bottom: 0;
            background: rgba(0, 122, 255, 0.1);
            pointer-events: none;
        }
        
        /* Task Card Styles */
        .task-card-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        
        .task-card {
            position: relative;
            display: flex;
            align-items: flex-start;
            gap: 12px;
            padding: 16px 14px;
            margin: 6px 0;
            border: 1px solid var(--writa-border-color, rgba(128, 128, 128, 0.2));
            border-radius: 16px;
            background: var(--writa-card-bg, rgba(128, 128, 128, 0.05));
            transition: border-color 0.15s ease, box-shadow 0.15s ease;
        }
        
        .task-card:hover {
            border-color: var(--writa-border-hover, rgba(128, 128, 128, 0.3));
        }
        
        .task-card:focus-within {
            border-color: var(--writa-accent-color, #007AFF);
            box-shadow: 0 0 0 3px var(--writa-accent-shadow, rgba(0, 122, 255, 0.15));
        }
        
        .task-card.is-completed {
            opacity: 0.6;
        }
        
        .task-card.is-completed .task-card-title {
            text-decoration: line-through;
            color: var(--writa-text-secondary, #888);
        }
        
        .task-card-checkbox {
            flex-shrink: 0;
            width: 18px;
            height: 18px;
            margin-top: 2px; /* Align with first line of title */
            border: 2px solid var(--writa-checkbox-border, rgba(128, 128, 128, 0.4));
            border-radius: 5px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.15s ease;
            background: transparent;
            user-select: none;
        }
        
        .task-card-checkbox:hover {
            border-color: var(--writa-accent-color, #007AFF);
            background: var(--writa-accent-shadow, rgba(0, 122, 255, 0.1));
        }
        
        .task-card.is-completed .task-card-checkbox {
            background: var(--writa-success-color, #34C759);
            border-color: var(--writa-success-color, #34C759);
        }
        
        .task-card.is-completed .task-card-checkbox::after {
            content: '✓';
            color: white;
            font-size: 11px;
            font-weight: bold;
            line-height: 1;
        }
        
        .task-card-content {
            flex: 1;
            min-width: 0;
        }
        
        .task-card-title {
            font-weight: 500;
            font-size: 0.9em;
            line-height: 1.4;
            outline: none;
            min-height: 1.4em;
        }
        
        .task-card-title.is-empty::before,
        .task-card-title:empty::before {
            content: 'What needs to be done?';
            color: var(--writa-text-placeholder, #999);
            pointer-events: none;
            float: left;
            height: 0;
        }
        
        .task-card-description {
            font-size: 0.8em;
            color: var(--writa-text-secondary, #666);
            line-height: 1.4;
            margin-top: 2px;
            outline: none;
            min-height: 1.4em;
            transition: opacity 0.15s ease, min-height 0.15s ease;
        }
        
        /* Description nodes are now dynamically added/removed, not hidden */
        
        .task-card-title:focus,
        .task-card-description:focus {
            outline: none;
        }
        
        /* TipTap Placeholder styling */
        .tiptap .is-empty::before {
            color: var(--writa-text-placeholder, #999);
            pointer-events: none;
            float: left;
            height: 0;
        }
        
        .tiptap .task-card-title.is-empty::before {
            content: 'What needs to be done?';
        }
        
        .tiptap .task-card-description.is-empty::before {
            content: 'Add notes...';
        }
        
        /* Fallback placeholder using :empty (for when .is-empty isn't added) */
        .task-card-title:not(.is-empty):empty::before,
        .task-card-title > br:only-child::before {
            content: 'What needs to be done?';
            color: var(--writa-text-placeholder, #999);
            pointer-events: none;
        }
        
        .task-card-description:not(.is-empty):empty::before,
        .task-card-description > br:only-child::before {
            content: 'Press Tab for description';
            color: var(--writa-text-placeholder, #999);
            pointer-events: none;
        }
        
        /* Floating Task Card Action Bar */
        #task-action-bar {
            display: none;
            position: fixed;
            gap: 4px;
            align-items: center;
            z-index: 1000;
            pointer-events: auto;
        }
        
        #task-action-bar.visible {
            display: flex;
        }
        
        .task-card-action {
            display: inline-flex;
            align-items: center;
            height: 20px;
            gap: 3px;
            padding: 0 6px;
            font-size: 10px;
            color: var(--writa-text-secondary, #666);
            background: var(--writa-chip-bg, rgba(128, 128, 128, 0.08));
            border: 1px solid var(--writa-border-color, rgba(128, 128, 128, 0.15));
            border-radius: 4px;
            cursor: pointer;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            white-space: nowrap;
            transition: all 0.15s ease;
        }
        
        .task-card-action:hover {
            background: var(--writa-chip-hover, rgba(128, 128, 128, 0.15));
            border-color: var(--writa-border-hover, rgba(128, 128, 128, 0.25));
            color: var(--writa-text-primary, #333);
        }
        
        .task-card-action-shortcut {
            font-size: 9px;
            opacity: 0.6;
        }
        
        .task-card-action--delete:hover {
            background: rgba(255, 59, 48, 0.1);
            border-color: rgba(255, 59, 48, 0.3);
            color: #ff3b30;
        }
        
        .task-card-action:active {
            transform: scale(0.95);
        }
        
        .task-card-action-shortcut {
            font-weight: 600;
            opacity: 0.7;
        }
        
        .task-card-action--delete:hover {
            background: rgba(255, 59, 48, 0.15);
            color: #FF3B30;
        }
    </style>
    <style id="theme-styles"></style>
</head>
<body>
    <div id="editor"></div>
    
    <!-- Floating action bar for task cards -->
    <div id="task-action-bar">
        <button type="button" class="task-card-action" data-action="new-task">
            <span class="task-card-action-shortcut">↵</span> New Task
        </button>
        <button type="button" class="task-card-action" data-action="description">
            <span class="task-card-action-shortcut">⇥</span> Description
        </button>
        <button type="button" class="task-card-action task-card-action--delete" data-action="delete">
            Delete
        </button>
    </div>
    
    <script type="module">
        import { Editor, Node, mergeAttributes } from 'https://esm.sh/@tiptap/core@2.1.13'
        import StarterKit from 'https://esm.sh/@tiptap/starter-kit@2.1.13'
        import Placeholder from 'https://esm.sh/@tiptap/extension-placeholder@2.1.13'
        import Underline from 'https://esm.sh/@tiptap/extension-underline@2.1.13'
        import Link from 'https://esm.sh/@tiptap/extension-link@2.1.13'
        import TaskList from 'https://esm.sh/@tiptap/extension-task-list@2.1.13'
        import TaskItem from 'https://esm.sh/@tiptap/extension-task-item@2.1.13'
        import Image from 'https://esm.sh/@tiptap/extension-image@2.1.13'
        import Table from 'https://esm.sh/@tiptap/extension-table@2.1.13'
        import TableRow from 'https://esm.sh/@tiptap/extension-table-row@2.1.13'
        import TableCell from 'https://esm.sh/@tiptap/extension-table-cell@2.1.13'
        import TableHeader from 'https://esm.sh/@tiptap/extension-table-header@2.1.13'
        import Highlight from 'https://esm.sh/@tiptap/extension-highlight@2.1.13'
        import TextAlign from 'https://esm.sh/@tiptap/extension-text-align@2.1.13'
        import Subscript from 'https://esm.sh/@tiptap/extension-subscript@2.1.13'
        import Superscript from 'https://esm.sh/@tiptap/extension-superscript@2.1.13'
        import Color from 'https://esm.sh/@tiptap/extension-color@2.1.13'
        import TextStyle from 'https://esm.sh/@tiptap/extension-text-style@2.1.13'
        
        // ============================================
        // Helper: Find ancestor node at a specific depth
        // ============================================
        function findAncestor($pos, typeName) {
            for (let d = $pos.depth; d > 0; d--) {
                if ($pos.node(d).type.name === typeName) {
                    return { node: $pos.node(d), depth: d }
                }
            }
            return null
        }
        
        // Helper: Check if a task card is empty (no text in title or description)
        function isTaskCardEmpty(taskCard) {
            let empty = true
            taskCard.forEach(child => {
                if (child.textContent.length > 0) empty = false
            })
            return empty
        }
        
        // Helper: Create a new empty task card node (without description - added on Tab)
        function createTaskCard(schema, includeDescription = false) {
            const title = schema.nodes.taskCardTitle.create()
            if (includeDescription) {
                const description = schema.nodes.taskCardDescription.create()
                return schema.nodes.taskCard.create({ checked: false }, [title, description])
            }
            return schema.nodes.taskCard.create({ checked: false }, [title])
        }
        
        // ============================================
        // TaskCardList Node
        // ============================================
        const TaskCardList = Node.create({
            name: 'taskCardList',
            group: 'block',
            content: 'taskCard+',
            
            parseHTML() {
                return [{ tag: 'div[data-type="task-card-list"]' }]
            },
            
            renderHTML({ HTMLAttributes }) {
                return ['div', mergeAttributes(HTMLAttributes, { 
                    'data-type': 'task-card-list',
                    'class': 'task-card-list'
                }), 0]
            }
        })
        
        // ============================================
        // TaskCard Node
        // ============================================
        const TaskCard = Node.create({
            name: 'taskCard',
            group: 'block',
            content: 'taskCardTitle taskCardDescription?',
            defining: true,
            
            addAttributes() {
                return {
                    checked: {
                        default: false,
                        parseHTML: el => el.getAttribute('data-checked') === 'true',
                        renderHTML: attrs => ({ 'data-checked': attrs.checked ? 'true' : 'false' })
                    }
                }
            },
            
            parseHTML() {
                return [{ tag: 'div[data-type="task-card"]' }]
            },
            
            renderHTML({ node, HTMLAttributes }) {
                return ['div', mergeAttributes(HTMLAttributes, { 
                    'data-type': 'task-card',
                    'class': `task-card ${node.attrs.checked ? 'is-completed' : ''}`
                }), 
                    ['div', { class: 'task-card-checkbox' }],
                    ['div', { class: 'task-card-content' }, 0]
                ]
            },
            
            addCommands() {
                return {
                    // Insert a new task card (or list with task card if not in one)
                    insertTaskCard: () => ({ chain, state, editor }) => {
                        const { schema, selection: { $from } } = state
                        const taskCard = createTaskCard(schema)
                        
                        // If already in a task card list, insert after current task
                        if (editor.isActive('taskCardList')) {
                            const ancestor = findAncestor($from, 'taskCard')
                            if (ancestor) {
                                const insertPos = $from.after(ancestor.depth)
                                // Position: +1 into taskCard, +1 into title
                                return chain()
                                    .insertContentAt(insertPos, taskCard.toJSON())
                                    .setTextSelection(insertPos + 2)
                                    .run()
                            }
                        }
                        
                        // Create new list - replace current block entirely
                        // Use before/after to get positions OUTSIDE the block (not inside)
                        const blockStart = $from.before($from.depth)
                        const blockEnd = $from.after($from.depth)
                        const taskCardList = schema.nodes.taskCardList.create(null, [taskCard])
                        
                        // Position: +1 into list, +1 into taskCard, +1 into title
                        return chain()
                            .deleteRange({ from: blockStart, to: blockEnd })
                            .insertContentAt(blockStart, taskCardList.toJSON())
                            .setTextSelection(blockStart + 3)
                            .run()
                    },
                    
                    // Toggle the checked state of the current task card
                    // Uses direct transaction since TipTap lacks ancestor attribute commands
                    toggleTaskCardChecked: () => ({ tr, state, dispatch }) => {
                        const ancestor = findAncestor(state.selection.$from, 'taskCard')
                        if (!ancestor) return false
                        
                        if (dispatch) {
                            const pos = state.selection.$from.before(ancestor.depth)
                            tr.setNodeMarkup(pos, undefined, {
                                ...ancestor.node.attrs,
                                checked: !ancestor.node.attrs.checked
                            })
                            dispatch(tr)
                        }
                        return true
                    }
                }
            },
            
            addKeyboardShortcuts() {
                return {
                    // Toggle completion with Cmd/Ctrl+Enter
                    'Mod-Enter': () => this.editor.commands.toggleTaskCardChecked(),
                    
                    // Enter: create new task or exit if empty
                    'Enter': ({ editor }) => {
                        if (!editor.isActive('taskCard')) return false
                        
                        const { state } = editor
                        const { $from } = state.selection
                        const taskAncestor = findAncestor($from, 'taskCard')
                        if (!taskAncestor) return false
                        
                        const { node: taskCard, depth: taskCardDepth } = taskAncestor
                        
                        // If task is empty, exit task card formatting
                        if (isTaskCardEmpty(taskCard)) {
                            const listAncestor = findAncestor($from, 'taskCardList')
                            if (!listAncestor) return false
                            
                            const { node: list, depth: listDepth } = listAncestor
                            
                            if (list.childCount === 1) {
                                // Only task in list - replace entire list with paragraph
                                const listStart = $from.before(listDepth)
                                const listEnd = $from.after(listDepth)
                                return editor.chain()
                                    .deleteRange({ from: listStart, to: listEnd })
                                    .insertContentAt(listStart, { type: 'paragraph' })
                                    .setTextSelection(listStart + 1)
                                    .run()
                            } else {
                                // Multiple tasks - just delete this one
                                return editor.chain()
                                    .deleteRange({ 
                                        from: $from.before(taskCardDepth), 
                                        to: $from.after(taskCardDepth) 
                                    })
                                    .run()
                            }
                        }
                        
                        // Not empty - create new task after current
                        const insertPos = $from.after(taskCardDepth)
                        return editor.chain()
                            .insertContentAt(insertPos, createTaskCard(state.schema).toJSON())
                            .setTextSelection(insertPos + 2) // +1 taskCard, +1 title
                            .run()
                    },
                    
                    // Tab: move from title to description (create if doesn't exist)
                    'Tab': ({ editor }) => {
                        if (!editor.isActive('taskCard')) return false
                        
                        const { state } = editor
                        const { $from } = state.selection
                        const titleAncestor = findAncestor($from, 'taskCardTitle')
                        if (!titleAncestor) return false
                        
                        const taskCardDepth = titleAncestor.depth - 1
                        const taskCard = $from.node(taskCardDepth)
                        const taskCardStart = $from.before(taskCardDepth)
                        
                        // Check if description exists
                        let hasDescription = false
                        let descPos = null
                        let offset = 1
                        taskCard.forEach(child => {
                            if (child.type.name === 'taskCardTitle') {
                                offset += child.nodeSize
                            } else if (child.type.name === 'taskCardDescription') {
                                hasDescription = true
                                descPos = taskCardStart + offset + 1
                            }
                        })
                        
                        if (hasDescription && descPos) {
                            // Move to existing description
                            return editor.commands.setTextSelection(descPos)
                        }
                        
                        // Create new description at end of taskCard
                        const insertPos = $from.after(taskCardDepth) - 1 // Before taskCard closes
                        const newDesc = state.schema.nodes.taskCardDescription.create()
                        
                        return editor.chain()
                            .insertContentAt(insertPos, newDesc.toJSON())
                            .setTextSelection(insertPos + 1) // Inside new description
                            .run()
                    },
                    
                    // Shift+Tab: move from description to title
                    'Shift-Tab': ({ editor }) => {
                        if (!editor.isActive('taskCard')) return false
                        
                        const { $from } = editor.state.selection
                        const descAncestor = findAncestor($from, 'taskCardDescription')
                        if (!descAncestor) return false
                        
                        const taskCardStart = $from.before(descAncestor.depth - 1)
                        // Title position: +1 (into taskCard), +1 (into title)
                        return editor.commands.setTextSelection(taskCardStart + 2)
                    },
                    
                    // Backspace at start of empty title: exit task formatting
                    'Backspace': ({ editor }) => {
                        if (!editor.isActive('taskCard')) return false
                        
                        const { selection, selection: { $from } } = editor.state
                        
                        // Only handle empty selection at start of content
                        if (!selection.empty || $from.parentOffset !== 0) return false
                        
                        const titleAncestor = findAncestor($from, 'taskCardTitle')
                        if (!titleAncestor) return false
                        
                        const taskCardDepth = titleAncestor.depth - 1
                        const taskCard = $from.node(taskCardDepth)
                        
                        // Only handle if task is empty
                        if (!isTaskCardEmpty(taskCard)) return false
                        
                        const listAncestor = findAncestor($from, 'taskCardList')
                        if (!listAncestor) return false
                        
                        const { node: list, depth: listDepth } = listAncestor
                        
                        if (list.childCount === 1) {
                            // Only task - replace list with paragraph
                            const listStart = $from.before(listDepth)
                            return editor.chain()
                                .deleteRange({ from: listStart, to: $from.after(listDepth) })
                                .insertContentAt(listStart, { type: 'paragraph' })
                                .setTextSelection(listStart + 1)
                                .run()
                        } else {
                            // Delete just this task
                            return editor.chain()
                                .deleteRange({ 
                                    from: $from.before(taskCardDepth), 
                                    to: $from.after(taskCardDepth) 
                                })
                                .run()
                        }
                    }
                }
            },
            
            // Custom node view for interactive checkbox
            addNodeView() {
                return ({ node, getPos, editor }) => {
                    const dom = document.createElement('div')
                    dom.className = `task-card ${node.attrs.checked ? 'is-completed' : ''}`
                    dom.setAttribute('data-type', 'task-card')
                    
                    // Checkbox
                    const checkbox = document.createElement('div')
                    checkbox.className = 'task-card-checkbox'
                    checkbox.setAttribute('contenteditable', 'false')
                    
                    checkbox.addEventListener('mousedown', (e) => {
                        e.preventDefault()
                        e.stopPropagation()
                        
                        const pos = getPos()
                        if (typeof pos === 'number') {
                            const currentNode = editor.state.doc.nodeAt(pos)
                            if (currentNode && currentNode.type.name === 'taskCard') {
                                editor.view.dispatch(
                                    editor.state.tr.setNodeMarkup(pos, undefined, {
                                        ...currentNode.attrs,
                                        checked: !currentNode.attrs.checked
                                    })
                                )
                            }
                        }
                    })
                    
                    // Content area (managed by TipTap)
                    const content = document.createElement('div')
                    content.className = 'task-card-content'
                    
                    dom.appendChild(checkbox)
                    dom.appendChild(content)
                    
                    return {
                        dom,
                        contentDOM: content,
                        update: (updatedNode) => {
                            if (updatedNode.type.name !== 'taskCard') return false
                            dom.className = `task-card ${updatedNode.attrs.checked ? 'is-completed' : ''}`
                            return true
                        }
                    }
                }
            }
        })
        
        // TaskCardTitle
        const TaskCardTitle = Node.create({
            name: 'taskCardTitle',
            group: 'block',
            content: 'inline*',
            defining: true,
            
            parseHTML() {
                return [{ tag: 'div[data-type="task-card-title"]' }]
            },
            
            renderHTML({ HTMLAttributes }) {
                return ['div', mergeAttributes(HTMLAttributes, { 
                    'data-type': 'task-card-title',
                    'class': 'task-card-title',
                    'data-placeholder': 'What needs to be done?'
                }), 0]
            }
        })
        
        // TaskCardDescription
        const TaskCardDescription = Node.create({
            name: 'taskCardDescription',
            group: 'block',
            content: 'inline*',
            
            parseHTML() {
                return [{ tag: 'div[data-type="task-card-description"]' }]
            },
            
            renderHTML({ HTMLAttributes }) {
                return ['div', mergeAttributes(HTMLAttributes, { 
                    'data-type': 'task-card-description',
                    'class': 'task-card-description',
                    'data-placeholder': 'Press Tab for description'
                }), 0]
            }
        })
        
        // ============================================
        // Editor Setup
        // ============================================
        
        function sendToSwift(msg) {
            if (window.webkit?.messageHandlers?.tiptap) {
                window.webkit.messageHandlers.tiptap.postMessage(msg);
            }
        }
        
        function getState() {
            if (!window.editor) return {};
            var e = window.editor;
            return {
                isBold: e.isActive('bold'),
                isItalic: e.isActive('italic'),
                isUnderline: e.isActive('underline'),
                isStrike: e.isActive('strike'),
                isCode: e.isActive('code'),
                isCodeBlock: e.isActive('codeBlock'),
                isBlockquote: e.isActive('blockquote'),
                isBulletList: e.isActive('bulletList'),
                isOrderedList: e.isActive('orderedList'),
                isTaskList: e.isActive('taskList'),
                isTaskCard: e.isActive('taskCard'),
                isHighlight: e.isActive('highlight'),
                isSubscript: e.isActive('subscript'),
                isSuperscript: e.isActive('superscript'),
                headingLevel: e.isActive('heading', { level: 1 }) ? 1 : 
                              e.isActive('heading', { level: 2 }) ? 2 : 
                              e.isActive('heading', { level: 3 }) ? 3 : 0,
                isLink: e.isActive('link'),
                textAlign: e.isActive({ textAlign: 'left' }) ? 'left' :
                          e.isActive({ textAlign: 'center' }) ? 'center' :
                          e.isActive({ textAlign: 'right' }) ? 'right' :
                          e.isActive({ textAlign: 'justify' }) ? 'justify' : 'left',
                canUndo: e.can().undo(),
                canRedo: e.can().redo()
            };
        }
        
        // Track previous task card to clean up empty descriptions when leaving
        let previousTaskCardPos = null;
        function cleanupEmptyDescriptions(editor) {
            const { state } = editor;
            const { doc, schema } = state;
            
            // Find all task cards with empty descriptions and remove them
            const changes = [];
            doc.descendants((node, pos) => {
                if (node.type.name === 'taskCard') {
                    node.forEach((child, offset) => {
                        if (child.type.name === 'taskCardDescription' && child.textContent === '') {
                            // Calculate absolute position of description
                            const descStart = pos + 1 + offset;
                            const descEnd = descStart + child.nodeSize;
                            changes.push({ from: descStart, to: descEnd });
                        }
                    });
                }
            });
            
            // Apply deletions in reverse order to preserve positions
            if (changes.length > 0) {
                let tr = state.tr;
                changes.reverse().forEach(({ from, to }) => {
                    tr = tr.delete(from, to);
                });
                editor.view.dispatch(tr);
            }
        }
        
        function onSelectionChange(editor) {
            const { state } = editor;
            const { $from } = state.selection;
            
            // Find current task card position using ProseMirror state
            let currentTaskCardPos = null;
            for (let d = $from.depth; d > 0; d--) {
                if ($from.node(d).type.name === 'taskCard') {
                    currentTaskCardPos = $from.before(d);
                    break;
                }
            }
            
            // Position and show/hide floating action bar
            const actionBar = document.getElementById('task-action-bar');
            if (actionBar) {
                if (currentTaskCardPos !== null) {
                    // Find the DOM element for the focused task card
                    const sel = window.getSelection();
                    if (sel && sel.anchorNode) {
                        // Use numeric constant (1) instead of Node.ELEMENT_NODE to avoid conflict with TipTap's Node import
                        const focusedCard = sel.anchorNode.nodeType === 1 
                            ? sel.anchorNode.closest('.task-card')
                            : sel.anchorNode.parentElement?.closest('.task-card');
                        if (focusedCard) {
                            // Position using fixed positioning (viewport-relative)
                            // getBoundingClientRect() returns viewport coordinates, which matches position: fixed
                            const cardRect = focusedCard.getBoundingClientRect();
                            
                            actionBar.style.top = (cardRect.bottom - 26) + 'px';
                            actionBar.style.right = (window.innerWidth - cardRect.right + 10) + 'px';
                            actionBar.classList.add('visible');
                            
                            // Store the current task card position for button actions
                            actionBar.dataset.taskCardPos = currentTaskCardPos;
                        } else {
                            actionBar.classList.remove('visible');
                        }
                    } else {
                        actionBar.classList.remove('visible');
                    }
                } else {
                    actionBar.classList.remove('visible');
                }
            }
            
            // If we left a task card, clean up its empty description
            if (previousTaskCardPos !== null && previousTaskCardPos !== currentTaskCardPos) {
                // Delay cleanup to avoid interfering with current operation
                setTimeout(() => cleanupEmptyDescriptions(editor), 10);
            }
            
            previousTaskCardPos = currentTaskCardPos;
        }
        
        try {
            sendToSwift({ type: 'debug', message: 'Starting editor initialization...' });
            
            const editor = new Editor({
                element: document.getElementById('editor'),
                extensions: [
                    StarterKit.configure({
                        heading: { levels: [1, 2, 3] }
                    }),
                    Placeholder.configure({ 
                        placeholder: ({ node }) => {
                            if (node.type.name === 'taskCardTitle') return 'What needs to be done?'
                            if (node.type.name === 'taskCardDescription') return 'Add notes...'
                            return 'Start writing...'
                        },
                        includeChildren: true,
                        showOnlyCurrent: false
                    }),
                    Underline,
                    Link.configure({
                        openOnClick: false,
                        HTMLAttributes: { class: 'link' }
                    }),
                    TaskList,
                    TaskItem.configure({ nested: true }),
                    TaskCardList,
                    TaskCard,
                    TaskCardTitle,
                    TaskCardDescription,
                    Image.configure({
                        HTMLAttributes: { class: 'image' }
                    }),
                    Table.configure({ resizable: true }),
                    TableRow,
                    TableHeader,
                    TableCell,
                    Highlight.configure({ multicolor: false }),
                    TextAlign.configure({ types: ['heading', 'paragraph'] }),
                    Subscript,
                    Superscript,
                    TextStyle,
                    Color
                ],
                content: '<p></p>',
                onUpdate: ({ editor }) => {
                    sendToSwift({
                        type: 'contentChange',
                        html: editor.getHTML(),
                        json: JSON.stringify(editor.getJSON()),
                        text: editor.getText()
                    });
                },
                onSelectionUpdate: ({ editor }) => {
                    sendToSwift({ type: 'selectionChange', state: getState() });
                    onSelectionChange(editor);
                }
            });
            
            window.editor = editor;
            
            window.editorBridge = {
                setContent: (html) => {
                    editor.commands.setContent(html || '<p></p>');
                },
                setContentJSON: (jsonStr) => { 
                    if (jsonStr) {
                        try {
                            const json = typeof jsonStr === 'string' ? JSON.parse(jsonStr) : jsonStr;
                            editor.commands.setContent(json);
                        } catch (e) {
                            console.error('Failed to parse JSON content:', e);
                        }
                    }
                },
                getContent: () => editor.getHTML(),
                getContentJSON: () => JSON.stringify(editor.getJSON()),
                getText: () => editor.getText(),
                
                toggleBold: () => editor.chain().focus().toggleBold().run(),
                toggleItalic: () => editor.chain().focus().toggleItalic().run(),
                toggleUnderline: () => editor.chain().focus().toggleUnderline().run(),
                toggleStrike: () => editor.chain().focus().toggleStrike().run(),
                toggleCode: () => editor.chain().focus().toggleCode().run(),
                toggleHighlight: () => editor.chain().focus().toggleHighlight().run(),
                toggleSubscript: () => editor.chain().focus().toggleSubscript().run(),
                toggleSuperscript: () => editor.chain().focus().toggleSuperscript().run(),
                
                setHeading: (level) => {
                    if (level === 0) editor.chain().focus().setParagraph().run();
                    else editor.chain().focus().toggleHeading({ level }).run();
                },
                toggleHeading1: () => editor.chain().focus().toggleHeading({ level: 1 }).run(),
                toggleHeading2: () => editor.chain().focus().toggleHeading({ level: 2 }).run(),
                toggleHeading3: () => editor.chain().focus().toggleHeading({ level: 3 }).run(),
                
                toggleBulletList: () => editor.chain().focus().toggleBulletList().run(),
                toggleOrderedList: () => editor.chain().focus().toggleOrderedList().run(),
                toggleTaskList: () => editor.chain().focus().toggleTaskList().run(),
                
                toggleTaskCard: () => editor.commands.insertTaskCard(),
                insertTaskCard: () => editor.commands.insertTaskCard(),
                toggleTaskCardChecked: () => editor.commands.toggleTaskCardChecked(),
                
                toggleBlockquote: () => editor.chain().focus().toggleBlockquote().run(),
                toggleCodeBlock: () => editor.chain().focus().toggleCodeBlock().run(),
                setHorizontalRule: () => editor.chain().focus().setHorizontalRule().run(),
                
                setLink: (url) => {
                    if (url) editor.chain().focus().setLink({ href: url }).run();
                    else editor.chain().focus().unsetLink().run();
                },
                unsetLink: () => editor.chain().focus().unsetLink().run(),
                
                insertImage: (src, alt) => {
                    if (src) editor.chain().focus().setImage({ src, alt: alt || '' }).run();
                },
                
                insertTable: () => editor.chain().focus()
                    .insertTable({ rows: 3, cols: 3, withHeaderRow: true }).run(),
                deleteTable: () => editor.chain().focus().deleteTable().run(),
                addColumnBefore: () => editor.chain().focus().addColumnBefore().run(),
                addColumnAfter: () => editor.chain().focus().addColumnAfter().run(),
                deleteColumn: () => editor.chain().focus().deleteColumn().run(),
                addRowBefore: () => editor.chain().focus().addRowBefore().run(),
                addRowAfter: () => editor.chain().focus().addRowAfter().run(),
                deleteRow: () => editor.chain().focus().deleteRow().run(),
                toggleHeaderCell: () => editor.chain().focus().toggleHeaderCell().run(),
                mergeCells: () => editor.chain().focus().mergeCells().run(),
                splitCell: () => editor.chain().focus().splitCell().run(),
                
                setTextAlign: (align) => editor.chain().focus().setTextAlign(align).run(),
                setColor: (color) => editor.chain().focus().setColor(color).run(),
                unsetColor: () => editor.chain().focus().unsetColor().run(),
                
                undo: () => editor.chain().focus().undo().run(),
                redo: () => editor.chain().focus().redo().run(),
                
                focus: () => editor.commands.focus(),
                blur: () => editor.commands.blur(),
                getState: () => JSON.stringify(getState()),
                setThemeCSS: (css) => {
                    const el = document.getElementById('theme-styles');
                    if (el) el.textContent = css;
                }
            };
            
            editor.commands.focus();
            sendToSwift({ type: 'ready' });
            sendToSwift({ type: 'debug', message: 'Editor initialized successfully!' });
            
            // Update action bar position on scroll (required for position: fixed)
            const editorElement = document.getElementById('editor');
            if (editorElement) {
                editorElement.addEventListener('scroll', () => {
                    const actionBar = document.getElementById('task-action-bar');
                    if (actionBar && actionBar.classList.contains('visible')) {
                        onSelectionChange(editor);
                    }
                }, { passive: true });
            }
            
            // Set up floating action bar click handlers
            const actionBar = document.getElementById('task-action-bar');
            if (actionBar) {
                actionBar.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    const action = e.target.closest('[data-action]')?.dataset.action;
                    if (!action) return;
                    
                    const taskCardPos = parseInt(actionBar.dataset.taskCardPos, 10);
                    if (isNaN(taskCardPos)) return;
                    
                    if (action === 'new-task') {
                        editor.commands.insertTaskCard();
                    } else if (action === 'description') {
                        // Focus into the task card title first
                        editor.commands.setTextSelection(taskCardPos + 2);
                        setTimeout(() => {
                            const { state } = editor;
                            const { $from } = state.selection;
                            const taskCard = $from.node($from.depth - 1);
                            const taskCardStart = $from.before($from.depth - 1);
                            
                            let hasDescription = false;
                            let descPos = null;
                            let offset = 1;
                            if (taskCard) {
                                taskCard.forEach(child => {
                                    if (child.type.name === 'taskCardTitle') {
                                        offset += child.nodeSize;
                                    } else if (child.type.name === 'taskCardDescription') {
                                        hasDescription = true;
                                        descPos = taskCardStart + offset + 1;
                                    }
                                });
                            }
                            
                            if (hasDescription && descPos) {
                                editor.commands.setTextSelection(descPos);
                            } else {
                                const insertPos = $from.after($from.depth - 1) - 1;
                                const newDesc = state.schema.nodes.taskCardDescription.create();
                                editor.chain()
                                    .insertContentAt(insertPos, newDesc.toJSON())
                                    .setTextSelection(insertPos + 1)
                                    .run();
                            }
                        }, 10);
                    } else if (action === 'delete') {
                        const currentNode = editor.state.doc.nodeAt(taskCardPos);
                        if (currentNode) {
                            editor.chain().deleteRange({ from: taskCardPos, to: taskCardPos + currentNode.nodeSize }).run();
                        }
                    }
                });
            }
            
        } catch (err) {
            sendToSwift({ type: 'debug', message: 'ERROR: ' + err.message });
            sendToSwift({ type: 'debug', message: 'Stack: ' + err.stack });
        }
    </script>
</body>
</html>

<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <style id="base-styles">
        * { box-sizing: border-box; }
        html, body { 
            margin: 0; 
            padding: 0; 
            background: transparent;
            height: 100%;
            overflow: hidden;
        }
        #editor {
            height: 100%;
            min-height: 100px;
            overflow-y: auto;
        }
        .tiptap { 
            outline: none;
            min-height: 100%;
            padding: 16px;
        }
        .tiptap p.is-editor-empty:first-child::before {
            color: #adb5bd;
            content: attr(data-placeholder);
            float: left;
            height: 0;
            pointer-events: none;
        }
        .tiptap .selectedCell:after {
            z-index: 2;
            position: absolute;
            content: "";
            left: 0; right: 0; top: 0; bottom: 0;
            background: rgba(0, 122, 255, 0.1);
            pointer-events: none;
        }
        
        /* Connection status indicator */
        #connection-status {
            position: fixed;
            top: 8px;
            right: 8px;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-family: -apple-system, BlinkMacSystemFont, sans-serif;
            z-index: 1000;
            transition: opacity 0.3s ease;
        }
        #connection-status.connected {
            background: rgba(52, 199, 89, 0.2);
            color: #34C759;
        }
        #connection-status.disconnected {
            background: rgba(255, 149, 0, 0.2);
            color: #FF9500;
        }
        #connection-status.syncing {
            background: rgba(0, 122, 255, 0.2);
            color: #007AFF;
        }
        
        /* Task Card Styles (same as original) */
        .task-card-list { list-style: none; padding: 0; margin: 0; }
        .task-card {
            position: relative;
            display: flex;
            align-items: flex-start;
            gap: 12px;
            padding: 18px 16px;
            margin: 6px 0;
            border: 1px solid var(--writa-border-color, rgba(128, 128, 128, 0.2));
            border-radius: 16px;
            background: var(--writa-card-bg, rgba(128, 128, 128, 0.05));
            transition: border-color 0.15s ease, box-shadow 0.15s ease;
        }
        .task-card:hover { border-color: var(--writa-border-hover, rgba(128, 128, 128, 0.3)); }
        .task-card:focus-within {
            border-color: var(--writa-accent-color, #007AFF);
            box-shadow: 0 0 0 3px var(--writa-accent-shadow, rgba(0, 122, 255, 0.15));
        }
        .task-card.is-completed { opacity: 0.6; }
        .task-card.is-completed .task-card-title { color: var(--writa-text-secondary, #888); }
        .task-card-checkbox {
            flex-shrink: 0;
            width: 18px;
            height: 18px;
            margin-top: 2px;
            border: 2px solid var(--writa-checkbox-border, rgba(128, 128, 128, 0.4));
            border-radius: 5px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.15s ease;
            background: transparent;
            user-select: none;
        }
        .task-card-checkbox:hover {
            border-color: var(--writa-success-color, #34C759);
            background: rgba(52, 199, 89, 0.15);
        }
        .task-card.is-completed .task-card-checkbox {
            background: var(--writa-success-color, #34C759);
            border-color: var(--writa-success-color, #34C759);
        }
        .task-card.is-completed .task-card-checkbox::after {
            content: '✓';
            color: white;
            font-size: 11px;
            font-weight: bold;
            line-height: 1;
        }
        .task-card-content { flex: 1; min-width: 0; }
        .task-card-title {
            font-weight: 500;
            font-size: 0.9em;
            line-height: 1.4;
            outline: none;
            min-height: 1.4em;
        }
        .task-card-title.is-empty::before,
        .task-card-title:empty::before {
            content: 'What needs to be done?';
            color: var(--writa-text-placeholder, #999);
            pointer-events: none;
            float: left;
            height: 0;
        }
        .task-card-description {
            font-size: 0.8em;
            color: var(--writa-text-secondary, #666);
            line-height: 1.4;
            margin-top: 2px;
            outline: none;
            min-height: 1.4em;
        }
        
        /* TipTap Placeholder styling */
        .tiptap .is-empty::before {
            color: var(--writa-text-placeholder, #999);
            pointer-events: none;
            float: left;
            height: 0;
        }
        .tiptap .task-card-title.is-empty::before { content: 'What needs to be done?'; }
        .tiptap .task-card-description.is-empty::before { content: 'Add notes...'; }
        .tiptap .prompt-snippet-title.is-empty::before { content: 'Snippet title...'; }
        .tiptap .prompt-snippet-body.is-empty::before { content: 'Write your prompt here...'; }
        
        /* Floating Task Card Action Bar */
        #task-action-bar {
            display: none;
            position: fixed;
            gap: 6px;
            align-items: center;
            z-index: 1000;
            pointer-events: auto;
        }
        #task-action-bar.visible { display: flex; }
        
        .task-card-action {
            display: inline-flex;
            align-items: center;
            gap: 2px;
            padding: 2px 4px;
            font-size: 10px;
            color: var(--writa-text-secondary, #666);
            background: transparent;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            white-space: nowrap;
            transition: color 0.15s ease;
        }
        .task-card-action:hover { color: var(--writa-text-primary, #333); }
        .task-card-action-shortcut { font-size: 9px; opacity: 0.7; }
        .task-card-action--delete:hover { color: #FF3B30; }
        
        /* Prompt Snippet Styles */
        .prompt-snippet-list { list-style: none; padding: 0; margin: 0; }
        .prompt-snippet {
            position: relative;
            display: flex;
            align-items: flex-start;
            gap: 12px;
            padding: 18px 16px;
            margin: 6px 0;
            border: 1px solid var(--writa-border-color, rgba(128, 128, 128, 0.2));
            border-radius: 16px;
            background: var(--writa-card-bg, rgba(128, 128, 128, 0.05));
            transition: border-color 0.15s ease, box-shadow 0.15s ease;
        }
        .prompt-snippet:hover { border-color: var(--writa-border-hover, rgba(128, 128, 128, 0.3)); }
        .prompt-snippet:focus-within {
            border-color: var(--writa-accent-color, #007AFF);
            box-shadow: 0 0 0 3px var(--writa-accent-shadow, rgba(0, 122, 255, 0.15));
        }
        
        .prompt-snippet-checkbox {
            flex-shrink: 0;
            width: 18px;
            height: 18px;
            margin-top: 2px;
            border: 2px solid var(--writa-checkbox-border, rgba(128, 128, 128, 0.4));
            border-radius: 5px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.15s ease;
            background: transparent;
            user-select: none;
        }
        .prompt-snippet-checkbox:hover {
            border-color: var(--writa-success-color, #34C759);
            background: rgba(52, 199, 89, 0.15);
        }
        .prompt-snippet.is-completed .prompt-snippet-checkbox {
            background: var(--writa-success-color, #34C759);
            border-color: var(--writa-success-color, #34C759);
        }
        .prompt-snippet.is-completed .prompt-snippet-checkbox::after {
            content: '✓';
            color: white;
            font-size: 11px;
            font-weight: bold;
            line-height: 1;
        }
        .prompt-snippet.is-completed { opacity: 0.6; }
        .prompt-snippet.is-completed .prompt-snippet-title { color: var(--writa-text-secondary, #888); }
        
        .prompt-snippet-content { flex: 1; min-width: 0; }
        .prompt-snippet-title {
            font-weight: 500;
            font-size: 0.9em;
            line-height: 1.4;
            outline: none;
            min-height: 1.4em;
            padding-right: 180px; /* Space for action buttons */
        }
        .prompt-snippet-body {
            font-size: 0.8em;
            color: var(--writa-text-secondary, #666);
            line-height: 1.4;
            margin-top: 2px;
            outline: none;
            min-height: 1.4em;
        }
        
        .prompt-snippet-actions {
            position: absolute;
            top: 8px;
            right: 8px;
            display: flex;
            gap: 4px;
        }
        .prompt-snippet-action {
            display: inline-flex;
            align-items: center;
            gap: 3px;
            padding: 3px 8px;
            font-size: 11px;
            color: var(--writa-text-secondary, #666);
            background: transparent;
            border: 1px solid var(--writa-border-color, rgba(128, 128, 128, 0.2));
            border-radius: 6px;
            cursor: pointer;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            transition: all 0.15s ease;
        }
        .prompt-snippet-action:hover {
            background: var(--writa-card-bg, rgba(128, 128, 128, 0.1));
            border-color: var(--writa-border-hover, rgba(128, 128, 128, 0.3));
        }
        .prompt-snippet-action--done {
            color: var(--writa-success-color, #34C759);
            border-color: var(--writa-success-color, #34C759);
        }
        .prompt-snippet-action--done:hover { background: rgba(52, 199, 89, 0.1); }
        .prompt-snippet-action--delete { color: var(--writa-text-secondary, #888); }
        .prompt-snippet-action--delete:hover {
            color: #FF3B30;
            border-color: #FF3B30;
            background: rgba(255, 59, 48, 0.1);
        }
        .prompt-snippet-action-icon { font-size: 12px; line-height: 1; }
        
        /* Collapsed state */
        .prompt-snippet.is-collapsed { cursor: pointer; }
        .prompt-snippet.is-collapsed:hover { background: var(--writa-card-hover-bg, rgba(128, 128, 128, 0.08)); }
        .prompt-snippet.is-collapsed .prompt-snippet-content { display: none; pointer-events: none; }
        .prompt-snippet.is-collapsed .prompt-snippet-actions { display: none; }
        
        .prompt-snippet-preview { display: none; flex: 1; min-width: 0; }
        .prompt-snippet.is-collapsed .prompt-snippet-preview { display: block; }
        .prompt-snippet-preview-title {
            font-weight: 500;
            font-size: 0.9em;
            color: var(--writa-text-primary, #333);
            line-height: 1.4;
            padding-right: 120px;
            pointer-events: none;
            user-select: none;
        }
        .prompt-snippet-preview-body {
            font-size: 0.8em;
            color: var(--writa-text-secondary, #888);
            line-height: 1.4;
            margin-top: 2px;
            overflow: hidden;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            pointer-events: none;
            user-select: none;
        }
        .prompt-snippet-preview-actions {
            display: none;
            position: absolute;
            top: 8px;
            right: 8px;
            gap: 4px;
        }
        .prompt-snippet.is-collapsed .prompt-snippet-preview-actions { display: flex; }
        
        /* Copy feedback */
        .prompt-snippet-copy-feedback {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 8px 16px;
            background: var(--writa-success-color, #34C759);
            color: white;
            border-radius: 8px;
            font-size: 13px;
            font-weight: 500;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease;
            z-index: 10;
        }
        .prompt-snippet-copy-feedback.visible { opacity: 1; }
        
        /* Collaboration cursors */
        .collaboration-cursor__caret {
            border-left: 1px solid #0d0d0d;
            border-right: 1px solid #0d0d0d;
            margin-left: -1px;
            margin-right: -1px;
            pointer-events: none;
            position: relative;
            word-break: normal;
        }
        .collaboration-cursor__label {
            border-radius: 3px 3px 3px 0;
            color: #fff;
            font-size: 12px;
            font-style: normal;
            font-weight: 600;
            left: -1px;
            line-height: normal;
            padding: 0.1rem 0.3rem;
            position: absolute;
            top: -1.4em;
            user-select: none;
            white-space: nowrap;
        }
    </style>
    <style id="theme-styles"></style>
</head>
<body>
    <div id="connection-status" class="disconnected">Offline</div>
    <div id="editor"></div>
    
    <!-- Floating action bar for task cards -->
    <div id="task-action-bar">
        <button type="button" class="task-card-action" data-action="new-task">
            <span class="task-card-action-shortcut">↵</span> New Task
        </button>
        <button type="button" class="task-card-action" data-action="description">
            <span class="task-card-action-shortcut">⇥</span> Description
        </button>
        <button type="button" class="task-card-action task-card-action--delete" data-action="delete">
            Delete
        </button>
    </div>
    
    <!-- Early error handler (runs before module) -->
    <script>
        function sendToSwift(msg) {
            if (window.webkit?.messageHandlers?.tiptap) {
                window.webkit.messageHandlers.tiptap.postMessage(msg);
            }
        }
        window.sendToSwift = sendToSwift;
        sendToSwift({ type: 'debug', message: 'Early script loaded, setting up error handlers...' });
        
        window.onerror = (msg, url, line, col, error) => {
            const stack = error?.stack || 'no stack';
            sendToSwift({ type: 'debug', message: `JS ERROR: ${msg} at ${url}:${line}:${col}` });
            sendToSwift({ type: 'debug', message: `JS STACK: ${stack.slice(0, 500)}` });
            console.error('Global error:', msg, error);
            return false;
        };
        
        window.addEventListener('unhandledrejection', (event) => {
            sendToSwift({ type: 'debug', message: `Unhandled Promise: ${event.reason}` });
            console.error('Unhandled rejection:', event.reason);
        });
    </script>
    
    <script type="module">
        // ============================================
        // Module loaded indicator
        // ============================================
        window.sendToSwift({ type: 'debug', message: 'Module script starting...' });
        
        // ============================================
        // Imports from local bundle (ensures consistent Yjs version)
        // ============================================
        let Editor, Node, mergeAttributes, StarterKit;
        let Placeholder, Underline, Link, TaskList, TaskItem;
        let Image, Table, TableRow, TableCell, TableHeader;
        let Highlight, TextAlign, Subscript, Superscript, TextStyle, Color;
        let Collaboration, CollaborationCursor, Y, YPartyKitProvider, IndexeddbPersistence;
        
        try {
            // Note: Xcode flattens bundle resources, so collab-bundle.js is in same dir as HTML
            window.sendToSwift({ type: 'debug', message: 'Importing bundle from ./collab-bundle.js...' });
            const bundle = await import('./collab-bundle.js');
            window.sendToSwift({ type: 'debug', message: `Bundle loaded! Keys: ${Object.keys(bundle).slice(0, 10).join(', ')}...` });
            
            // Destructure from bundle
            ({ Editor, Node, mergeAttributes, StarterKit,
               Placeholder, Underline, Link, TaskList, TaskItem,
               Image, Table, TableRow, TableCell, TableHeader,
               Highlight, TextAlign, Subscript, Superscript, TextStyle, Color,
               Collaboration, CollaborationCursor, Y,
               YPartyKitProvider, IndexeddbPersistence } = bundle);
               
            window.sendToSwift({ type: 'debug', message: `Imports ready: Editor=${!!Editor}, Y=${!!Y}, Collaboration=${!!Collaboration}` });
        } catch (err) {
            window.sendToSwift({ type: 'debug', message: `BUNDLE IMPORT ERROR: ${err.message}` });
            console.error('Bundle import error:', err);
            throw err;
        }
        
        // ============================================
        // Configuration (set by native app)
        // ============================================
        let PARTYKIT_HOST = 'writa-collab.jmaorr.partykit.dev' // Will be set by native app
        let DOCUMENT_ID = null
        let USER_ID = null
        let USER_NAME = 'Anonymous'
        let USER_COLOR = '#' + Math.floor(Math.random()*16777215).toString(16)
        
        // ============================================
        // Yjs Document and Provider (initialized per document)
        // ============================================
        let ydoc = null
        let wsProvider = null
        let indexeddbProvider = null
        let editor = null
        
        // ============================================
        // Helper Functions
        // ============================================
        function sendToSwift(msg) {
            if (window.webkit?.messageHandlers?.tiptap) {
                window.webkit.messageHandlers.tiptap.postMessage(msg);
            }
        }
        
        function updateConnectionStatus(status) {
            const el = document.getElementById('connection-status')
            if (!el) return
            
            el.className = status
            el.textContent = {
                'connected': 'Synced',
                'disconnected': 'Offline',
                'syncing': 'Syncing...'
            }[status] || status
            
            // Hide after connected
            if (status === 'connected') {
                setTimeout(() => { el.style.opacity = '0' }, 2000)
            } else {
                el.style.opacity = '1'
            }
        }
        
        function getState() {
            if (!editor) return {};
            var e = editor;
            return {
                isBold: e.isActive('bold'),
                isItalic: e.isActive('italic'),
                isUnderline: e.isActive('underline'),
                isStrike: e.isActive('strike'),
                isCode: e.isActive('code'),
                isCodeBlock: e.isActive('codeBlock'),
                isBlockquote: e.isActive('blockquote'),
                isBulletList: e.isActive('bulletList'),
                isOrderedList: e.isActive('orderedList'),
                isTaskList: e.isActive('taskList'),
                isTaskCard: e.isActive('taskCard'),
                isPromptSnippet: e.isActive('promptSnippet'),
                isHighlight: e.isActive('highlight'),
                isSubscript: e.isActive('subscript'),
                isSuperscript: e.isActive('superscript'),
                headingLevel: e.isActive('heading', { level: 1 }) ? 1 : 
                              e.isActive('heading', { level: 2 }) ? 2 : 
                              e.isActive('heading', { level: 3 }) ? 3 : 0,
                isLink: e.isActive('link'),
                textAlign: e.isActive({ textAlign: 'left' }) ? 'left' :
                          e.isActive({ textAlign: 'center' }) ? 'center' :
                          e.isActive({ textAlign: 'right' }) ? 'right' :
                          e.isActive({ textAlign: 'justify' }) ? 'justify' : 'left',
                canUndo: e.can().undo(),
                canRedo: e.can().redo()
            };
        }
        
        // ============================================
        // Helper Functions
        // ============================================
        
        // Find ancestor node by type name
        function findAncestor($pos, typeName) {
            for (let depth = $pos.depth; depth > 0; depth--) {
                const node = $pos.node(depth)
                if (node.type.name === typeName) {
                    return { node, depth }
                }
            }
            return null
        }
        
        // Check if task card is empty
        function isTaskCardEmpty(taskCard) {
            let empty = true
            taskCard.forEach(child => {
                if (child.textContent.length > 0) empty = false
            })
            return empty
        }
        
        // Create a new task card node
        function createTaskCard(schema, includeDescription = false) {
            const title = schema.nodes.taskCardTitle.create()
            if (includeDescription) {
                const description = schema.nodes.taskCardDescription.create()
                return schema.nodes.taskCard.create({ checked: false }, [title, description])
            }
            return schema.nodes.taskCard.create({ checked: false }, [title])
        }
        
        // Check if prompt snippet is empty
        function isPromptSnippetEmpty(snippet) {
            let empty = true
            snippet.forEach(child => {
                if (child.textContent.length > 0) empty = false
            })
            return empty
        }
        
        // Create a new prompt snippet node
        function createPromptSnippet(schema) {
            const title = schema.nodes.promptSnippetTitle.create()
            const body = schema.nodes.promptSnippetBody.create()
            return schema.nodes.promptSnippet.create({ expanded: true }, [title, body])
        }

        // Heal corrupted snippets in the document
        // This finds and fixes:
        // 1. Orphaned snippets (snippets without a parent list) - wraps them in a list
        // 2. Structurally invalid snippets (missing title/body) - removes them
        // 3. Empty snippet lists - removes them
        function healCorruptedSnippets(editor) {
            const { state } = editor
            const { doc, schema } = state
            let healed = 0
            let removed = 0

            // First pass: find orphaned snippets (direct children of doc, not inside a list)
            const orphanedSnippets = []
            const invalidSnippets = []
            const emptyLists = []

            doc.forEach((node, offset) => {
                // Check for orphaned snippets at the top level
                if (node.type.name === 'promptSnippet') {
                    // Check if structurally valid
                    let hasTitle = false
                    let hasBody = false
                    node.forEach(child => {
                        if (child.type.name === 'promptSnippetTitle') hasTitle = true
                        if (child.type.name === 'promptSnippetBody') hasBody = true
                    })

                    if (hasTitle && hasBody) {
                        // Valid but orphaned - needs to be wrapped in a list
                        orphanedSnippets.push({ pos: offset + 1, node, size: node.nodeSize })
                    } else {
                        // Invalid structure - mark for removal
                        invalidSnippets.push({ pos: offset + 1, size: node.nodeSize })
                    }
                }

                // Check snippet lists for empty/invalid ones
                if (node.type.name === 'promptSnippetList') {
                    let validSnippets = 0
                    node.forEach(child => {
                        if (child.type.name === 'promptSnippet') {
                            let hasTitle = false
                            let hasBody = false
                            child.forEach(grandchild => {
                                if (grandchild.type.name === 'promptSnippetTitle') hasTitle = true
                                if (grandchild.type.name === 'promptSnippetBody') hasBody = true
                            })
                            if (hasTitle && hasBody) validSnippets++
                        }
                    })

                    if (validSnippets === 0) {
                        emptyLists.push({ pos: offset + 1, size: node.nodeSize })
                    }
                }
            })

            // Also check nested content for orphaned snippets
            doc.descendants((node, pos, parent) => {
                if (node.type.name === 'promptSnippet' && parent && parent.type.name !== 'promptSnippetList' && parent.type.name !== 'doc') {
                    let hasTitle = false
                    let hasBody = false
                    node.forEach(child => {
                        if (child.type.name === 'promptSnippetTitle') hasTitle = true
                        if (child.type.name === 'promptSnippetBody') hasBody = true
                    })

                    if (hasTitle && hasBody) {
                        orphanedSnippets.push({ pos, node, size: node.nodeSize })
                    } else {
                        invalidSnippets.push({ pos, size: node.nodeSize })
                    }
                }
            })

            const totalIssues = orphanedSnippets.length + invalidSnippets.length + emptyLists.length

            if (totalIssues === 0) {
                return { healed: 0, removed: 0 }
            }

            sendToSwift({
                type: 'debug',
                message: `Healing: ${orphanedSnippets.length} orphaned, ${invalidSnippets.length} invalid, ${emptyLists.length} empty lists`
            })

            // Build transaction - process in reverse position order to maintain positions
            let tr = state.tr

            // Combine all items and sort by position descending
            const allItems = [
                ...orphanedSnippets.map(s => ({ ...s, type: 'orphan' })),
                ...invalidSnippets.map(s => ({ ...s, type: 'invalid' })),
                ...emptyLists.map(s => ({ ...s, type: 'emptyList' }))
            ].sort((a, b) => b.pos - a.pos)

            for (const item of allItems) {
                try {
                    if (item.type === 'orphan') {
                        // Wrap orphaned snippet in a list
                        const list = schema.nodes.promptSnippetList.create(null, [item.node])
                        tr = tr.replaceWith(item.pos, item.pos + item.size, list)
                        healed++
                        sendToSwift({ type: 'debug', message: `Wrapped orphaned snippet at ${item.pos} in list` })
                    } else {
                        // Remove invalid snippet or empty list
                        tr = tr.delete(item.pos, item.pos + item.size)
                        tr = tr.insert(item.pos, schema.nodes.paragraph.create())
                        removed++
                        sendToSwift({ type: 'debug', message: `Removed ${item.type} at ${item.pos}` })
                    }
                } catch (e) {
                    sendToSwift({ type: 'debug', message: `Error healing at ${item.pos}: ${e.message}` })
                }
            }

            if (healed > 0 || removed > 0) {
                editor.view.dispatch(tr)
                sendToSwift({ type: 'debug', message: `Healed document: wrapped ${healed} orphaned snippets, removed ${removed} invalid nodes` })
            }

            return { healed, removed }
        }

        // ============================================
        // Task Card Nodes
        // ============================================
        
        const TaskCardList = Node.create({
            name: 'taskCardList',
            group: 'block',
            content: 'taskCard+',
            parseHTML() { return [{ tag: 'div[data-type="task-card-list"]' }] },
            renderHTML({ HTMLAttributes }) {
                return ['div', mergeAttributes(HTMLAttributes, { 
                    'data-type': 'task-card-list',
                    'class': 'task-card-list'
                }), 0]
            }
        })
        
        const TaskCard = Node.create({
            name: 'taskCard',
            group: 'block',
            content: 'taskCardTitle taskCardDescription?',
            defining: true,
            
            addAttributes() {
                return {
                    checked: {
                        default: false,
                        parseHTML: el => el.getAttribute('data-checked') === 'true',
                        renderHTML: attrs => ({ 'data-checked': attrs.checked ? 'true' : 'false' })
                    }
                }
            },
            
            parseHTML() { return [{ tag: 'div[data-type="task-card"]' }] },
            
            renderHTML({ node, HTMLAttributes }) {
                return ['div', mergeAttributes(HTMLAttributes, { 
                    'data-type': 'task-card',
                    'class': `task-card ${node.attrs.checked ? 'is-completed' : ''}`
                }), 
                    ['div', { class: 'task-card-checkbox' }],
                    ['div', { class: 'task-card-content' }, 0]
                ]
            },
            
            addCommands() {
                return {
                    insertTaskCard: () => ({ chain, state, editor }) => {
                        const { schema, selection: { $from } } = state
                        const taskCard = createTaskCard(schema)
                        
                        if (editor.isActive('taskCardList')) {
                            const ancestor = findAncestor($from, 'taskCard')
                            if (ancestor) {
                                const insertPos = $from.after(ancestor.depth)
                                return chain()
                                    .insertContentAt(insertPos, taskCard.toJSON())
                                    .setTextSelection(insertPos + 2)
                                    .run()
                            }
                        }
                        
                        const blockStart = $from.before($from.depth)
                        const blockEnd = $from.after($from.depth)
                        const taskCardList = schema.nodes.taskCardList.create(null, [taskCard])
                        
                        return chain()
                            .deleteRange({ from: blockStart, to: blockEnd })
                            .insertContentAt(blockStart, taskCardList.toJSON())
                            .setTextSelection(blockStart + 3)
                            .run()
                    },
                    
                    toggleTaskCardChecked: () => ({ tr, state, dispatch }) => {
                        const ancestor = findAncestor(state.selection.$from, 'taskCard')
                        if (!ancestor) return false
                        
                        if (dispatch) {
                            const pos = state.selection.$from.before(ancestor.depth)
                            tr.setNodeMarkup(pos, undefined, {
                                ...ancestor.node.attrs,
                                checked: !ancestor.node.attrs.checked
                            })
                            dispatch(tr)
                        }
                        return true
                    }
                }
            },
            
            addKeyboardShortcuts() {
                return {
                    'Mod-Enter': () => this.editor.commands.toggleTaskCardChecked(),
                    
                    'Enter': ({ editor }) => {
                        if (!editor.isActive('taskCard')) return false
                        
                        const { state } = editor
                        const { $from } = state.selection
                        const taskAncestor = findAncestor($from, 'taskCard')
                        if (!taskAncestor) return false
                        
                        const { node: taskCard, depth: taskCardDepth } = taskAncestor
                        
                        if (isTaskCardEmpty(taskCard)) {
                            // Hide action bar immediately when exiting task card
                            const actionBar = document.getElementById('task-action-bar')
                            if (actionBar) actionBar.classList.remove('visible')
                            
                            const listAncestor = findAncestor($from, 'taskCardList')
                            if (!listAncestor) return false
                            
                            const { node: list, depth: listDepth } = listAncestor
                            const listEnd = $from.after(listDepth)
                            
                            if (list.childCount === 1) {
                                const listStart = $from.before(listDepth)
                                return editor.chain()
                                    .deleteRange({ from: listStart, to: listEnd })
                                    .insertContentAt(listStart, { type: 'paragraph' })
                                    .setTextSelection(listStart + 1)
                                    .run()
                            } else {
                                const taskStart = $from.before(taskCardDepth)
                                const taskEnd = $from.after(taskCardDepth)
                                return editor.chain()
                                    .deleteRange({ from: taskStart, to: taskEnd })
                                    .insertContentAt(listEnd - (taskEnd - taskStart), { type: 'paragraph' })
                                    .setTextSelection(listEnd - (taskEnd - taskStart) + 1)
                                    .run()
                            }
                        }
                        
                        const insertPos = $from.after(taskCardDepth)
                        return editor.chain()
                            .insertContentAt(insertPos, createTaskCard(state.schema).toJSON())
                            .setTextSelection(insertPos + 2)
                            .run()
                    },
                    
                    'Tab': ({ editor }) => {
                        if (!editor.isActive('taskCard')) return false
                        
                        const { state } = editor
                        const { $from } = state.selection
                        const titleAncestor = findAncestor($from, 'taskCardTitle')
                        if (!titleAncestor) return false
                        
                        const taskCardDepth = titleAncestor.depth - 1
                        const taskCard = $from.node(taskCardDepth)
                        const taskCardStart = $from.before(taskCardDepth)
                        
                        let hasDescription = false
                        let descPos = null
                        let offset = 1
                        taskCard.forEach(child => {
                            if (child.type.name === 'taskCardTitle') {
                                offset += child.nodeSize
                            } else if (child.type.name === 'taskCardDescription') {
                                hasDescription = true
                                descPos = taskCardStart + offset + 1
                            }
                        })
                        
                        if (hasDescription && descPos) {
                            return editor.commands.setTextSelection(descPos)
                        }
                        
                        const insertPos = $from.after(taskCardDepth) - 1
                        const newDesc = state.schema.nodes.taskCardDescription.create()
                        
                        return editor.chain()
                            .insertContentAt(insertPos, newDesc.toJSON())
                            .setTextSelection(insertPos + 1)
                            .run()
                    },
                    
                    'Shift-Tab': ({ editor }) => {
                        if (!editor.isActive('taskCard')) return false
                        
                        const { $from } = editor.state.selection
                        const descAncestor = findAncestor($from, 'taskCardDescription')
                        if (!descAncestor) return false
                        
                        const taskCardStart = $from.before(descAncestor.depth - 1)
                        return editor.commands.setTextSelection(taskCardStart + 2)
                    },
                    
                    'Backspace': ({ editor }) => {
                        if (!editor.isActive('taskCard')) return false
                        
                        const { selection, selection: { $from } } = editor.state
                        if (!selection.empty || $from.parentOffset !== 0) return false
                        
                        const titleAncestor = findAncestor($from, 'taskCardTitle')
                        if (!titleAncestor) return false
                        
                        const taskCardDepth = titleAncestor.depth - 1
                        const taskCard = $from.node(taskCardDepth)
                        if (!isTaskCardEmpty(taskCard)) return false
                        
                        // Hide action bar immediately when exiting task card
                        const actionBar = document.getElementById('task-action-bar')
                        if (actionBar) actionBar.classList.remove('visible')
                        
                        const listAncestor = findAncestor($from, 'taskCardList')
                        if (!listAncestor) return false
                        
                        const { node: list, depth: listDepth } = listAncestor
                        const listEnd = $from.after(listDepth)
                        
                        if (list.childCount === 1) {
                            const listStart = $from.before(listDepth)
                            return editor.chain()
                                .deleteRange({ from: listStart, to: listEnd })
                                .insertContentAt(listStart, { type: 'paragraph' })
                                .setTextSelection(listStart + 1)
                                .run()
                        } else {
                            const taskStart = $from.before(taskCardDepth)
                            const taskEnd = $from.after(taskCardDepth)
                            return editor.chain()
                                .deleteRange({ from: taskStart, to: taskEnd })
                                .insertContentAt(listEnd - (taskEnd - taskStart), { type: 'paragraph' })
                                .setTextSelection(listEnd - (taskEnd - taskStart) + 1)
                                .run()
                        }
                    }
                }
            },
            
            addNodeView() {
                return ({ node, getPos, editor }) => {
                    const dom = document.createElement('div')
                    dom.className = `task-card ${node.attrs.checked ? 'is-completed' : ''}`
                    dom.setAttribute('data-type', 'task-card')
                    
                    const checkbox = document.createElement('div')
                    checkbox.className = 'task-card-checkbox'
                    checkbox.setAttribute('contenteditable', 'false')
                    
                    checkbox.addEventListener('mousedown', (e) => {
                        e.preventDefault()
                        e.stopPropagation()
                        
                        const pos = getPos()
                        if (typeof pos === 'number') {
                            const currentNode = editor.state.doc.nodeAt(pos)
                            if (currentNode && currentNode.type.name === 'taskCard') {
                                editor.view.dispatch(
                                    editor.state.tr.setNodeMarkup(pos, undefined, {
                                        ...currentNode.attrs,
                                        checked: !currentNode.attrs.checked
                                    })
                                )
                            }
                        }
                    })
                    
                    const content = document.createElement('div')
                    content.className = 'task-card-content'
                    
                    dom.appendChild(checkbox)
                    dom.appendChild(content)
                    
                    return {
                        dom,
                        contentDOM: content,
                        update: (updatedNode) => {
                            if (updatedNode.type.name !== 'taskCard') return false
                            dom.className = `task-card ${updatedNode.attrs.checked ? 'is-completed' : ''}`
                            return true
                        }
                    }
                }
            }
        })
        
        const TaskCardTitle = Node.create({
            name: 'taskCardTitle',
            group: 'block',
            content: 'inline*',
            defining: true,
            parseHTML() { return [{ tag: 'div[data-type="task-card-title"]' }] },
            renderHTML({ HTMLAttributes }) {
                return ['div', mergeAttributes(HTMLAttributes, { 
                    'data-type': 'task-card-title',
                    'class': 'task-card-title',
                    'data-placeholder': 'What needs to be done?'
                }), 0]
            }
        })
        
        const TaskCardDescription = Node.create({
            name: 'taskCardDescription',
            group: 'block',
            content: 'inline*',
            parseHTML() { return [{ tag: 'div[data-type="task-card-description"]' }] },
            renderHTML({ HTMLAttributes }) {
                return ['div', mergeAttributes(HTMLAttributes, { 
                    'data-type': 'task-card-description',
                    'class': 'task-card-description',
                    'data-placeholder': 'Add notes...'
                }), 0]
            }
        })
        
        // ============================================
        // Prompt Snippet Nodes
        // ============================================
        
        const PromptSnippetList = Node.create({
            name: 'promptSnippetList',
            group: 'block',
            content: 'promptSnippet+',
            parseHTML() { return [{ tag: 'div[data-type="prompt-snippet-list"]' }] },
            renderHTML({ HTMLAttributes }) {
                return ['div', mergeAttributes(HTMLAttributes, { 
                    'data-type': 'prompt-snippet-list',
                    'class': 'prompt-snippet-list'
                }), 0]
            }
        })
        
        const PromptSnippet = Node.create({
            name: 'promptSnippet',
            group: 'block',
            content: 'promptSnippetTitle promptSnippetBody',
            defining: true,
            
            addAttributes() {
                return {
                    expanded: {
                        default: true,
                        parseHTML: el => el.getAttribute('data-expanded') !== 'false',
                        renderHTML: attrs => ({ 'data-expanded': attrs.expanded ? 'true' : 'false' })
                    },
                    completed: {
                        default: false,
                        parseHTML: el => el.getAttribute('data-completed') === 'true',
                        renderHTML: attrs => ({ 'data-completed': attrs.completed ? 'true' : 'false' })
                    }
                }
            },
            
            parseHTML() { return [{ tag: 'div[data-type="prompt-snippet"]' }] },
            
            renderHTML({ node, HTMLAttributes }) {
                const classes = ['prompt-snippet']
                if (!node.attrs.expanded) classes.push('is-collapsed')
                if (node.attrs.completed) classes.push('is-completed')
                return ['div', mergeAttributes(HTMLAttributes, { 
                    'data-type': 'prompt-snippet',
                    'class': classes.join(' ')
                }), 0]
            },
            
            addCommands() {
                return {
                    insertPromptSnippet: () => ({ chain, state, editor }) => {
                        const { schema, selection: { $from } } = state
                        const snippet = createPromptSnippet(schema)
                        
                        if (editor.isActive('promptSnippetList')) {
                            const ancestor = findAncestor($from, 'promptSnippet')
                            if (ancestor) {
                                const insertPos = $from.after(ancestor.depth)
                                return chain()
                                    .insertContentAt(insertPos, snippet.toJSON())
                                    .setTextSelection(insertPos + 2)
                                    .run()
                            }
                        }
                        
                        const blockStart = $from.before($from.depth)
                        const blockEnd = $from.after($from.depth)
                        const snippetList = schema.nodes.promptSnippetList.create(null, [snippet])
                        
                        return chain()
                            .deleteRange({ from: blockStart, to: blockEnd })
                            .insertContentAt(blockStart, snippetList.toJSON())
                            .setTextSelection(blockStart + 3)
                            .run()
                    },
                    
                    togglePromptSnippetExpanded: () => ({ tr, state, dispatch }) => {
                        const ancestor = findAncestor(state.selection.$from, 'promptSnippet')
                        if (!ancestor) return false
                        
                        if (dispatch) {
                            const pos = state.selection.$from.before(ancestor.depth)
                            const newExpanded = !ancestor.node.attrs.expanded
                            
                            tr.setNodeMarkup(pos, undefined, {
                                ...ancestor.node.attrs,
                                expanded: newExpanded
                            })
                            
                            if (!newExpanded) {
                                const afterSnippet = state.selection.$from.after(ancestor.depth)
                                tr.setSelection(state.selection.constructor.near(tr.doc.resolve(afterSnippet)))
                            }
                            
                            dispatch(tr)
                        }
                        return true
                    },
                    
                    copyPromptSnippet: () => ({ state }) => {
                        const ancestor = findAncestor(state.selection.$from, 'promptSnippet')
                        if (!ancestor) return false
                        
                        let bodyText = ''
                        ancestor.node.forEach(child => {
                            if (child.type.name === 'promptSnippetBody') {
                                bodyText = child.textContent
                            }
                        })
                        
                        if (bodyText) {
                            navigator.clipboard.writeText(bodyText)
                        }
                        return true
                    },
                    
                    expandPromptSnippetAt: (pos) => ({ tr, state, dispatch }) => {
                        const node = state.doc.nodeAt(pos)
                        if (!node || node.type.name !== 'promptSnippet') return false
                        
                        if (dispatch) {
                            tr.setNodeMarkup(pos, undefined, { ...node.attrs, expanded: true })
                            tr.setSelection(state.selection.constructor.near(tr.doc.resolve(pos + 2)))
                            dispatch(tr)
                        }
                        return true
                    },
                    
                    togglePromptSnippetCompleted: (pos) => ({ tr, state, dispatch }) => {
                        const node = state.doc.nodeAt(pos)
                        if (!node || node.type.name !== 'promptSnippet') return false

                        if (dispatch) {
                            tr.setNodeMarkup(pos, undefined, {
                                ...node.attrs,
                                completed: !node.attrs.completed
                            })
                            dispatch(tr)
                        }
                        return true
                    },

                    deletePromptSnippetAt: (pos) => ({ state, tr, dispatch }) => {
                        const node = state.doc.nodeAt(pos)
                        if (!node || node.type.name !== 'promptSnippet') return false

                        // Resolve position INSIDE the snippet to properly find ancestors
                        const $pos = state.doc.resolve(pos + 1)
                        let listDepth = null
                        let listNode = null
                        let snippetDepth = null

                        // Find both the snippet and list depths
                        for (let d = $pos.depth; d >= 0; d--) {
                            const n = $pos.node(d)
                            if (n.type.name === 'promptSnippet' && snippetDepth === null) {
                                snippetDepth = d
                            }
                            if (n.type.name === 'promptSnippetList') {
                                listDepth = d
                                listNode = n
                                break
                            }
                        }

                        // Handle orphaned snippets (no parent list) - just delete the snippet directly
                        if (!listNode || listDepth === null) {
                            if (snippetDepth === null) return false

                            const snippetStart = $pos.before(snippetDepth)
                            const snippetEnd = $pos.after(snippetDepth)

                            if (dispatch) {
                                tr.delete(snippetStart, snippetEnd)
                                tr.insert(snippetStart, state.schema.nodes.paragraph.create())
                                tr.setSelection(state.selection.constructor.near(tr.doc.resolve(snippetStart + 1)))
                                dispatch(tr)
                            }
                            return true
                        }

                        const listStart = $pos.before(listDepth)
                        const listEnd = $pos.after(listDepth)
                        const snippetStart = $pos.before(snippetDepth)
                        const snippetEnd = $pos.after(snippetDepth)

                        if (dispatch) {
                            if (listNode.childCount === 1) {
                                // Only snippet in list - delete whole list and insert paragraph
                                tr.delete(listStart, listEnd)
                                tr.insert(listStart, state.schema.nodes.paragraph.create())
                                tr.setSelection(state.selection.constructor.near(tr.doc.resolve(listStart + 1)))
                            } else {
                                // Multiple snippets - just delete this one
                                tr.delete(snippetStart, snippetEnd)
                            }
                            dispatch(tr)
                        }
                        return true
                    }
                }
            },
            
            addKeyboardShortcuts() {
                return {
                    'Escape': ({ editor }) => {
                        if (!editor.isActive('promptSnippet')) return false

                        const { $from } = editor.state.selection
                        const ancestor = findAncestor($from, 'promptSnippet')
                        if (!ancestor) return false

                        if (isPromptSnippetEmpty(ancestor.node)) {
                            const listAncestor = findAncestor($from, 'promptSnippetList')
                            const snippetStart = $from.before(ancestor.depth)
                            const snippetEnd = $from.after(ancestor.depth)

                            // Handle orphaned snippets (no parent list)
                            if (!listAncestor) {
                                return editor.chain()
                                    .deleteRange({ from: snippetStart, to: snippetEnd })
                                    .insertContentAt(snippetStart, { type: 'paragraph' })
                                    .setTextSelection(snippetStart + 1)
                                    .run()
                            }

                            const { node: list, depth: listDepth } = listAncestor
                            const listStart = $from.before(listDepth)
                            const listEnd = $from.after(listDepth)

                            if (list.childCount === 1) {
                                return editor.chain()
                                    .deleteRange({ from: listStart, to: listEnd })
                                    .insertContentAt(listStart, { type: 'paragraph' })
                                    .setTextSelection(listStart + 1)
                                    .run()
                            } else {
                                const snippetSize = snippetEnd - snippetStart
                                const newListEnd = listEnd - snippetSize
                                return editor.chain()
                                    .deleteRange({ from: snippetStart, to: snippetEnd })
                                    .insertContentAt(newListEnd, { type: 'paragraph' })
                                    .setTextSelection(newListEnd + 1)
                                    .run()
                            }
                        }

                        if (!ancestor.node.attrs.expanded) return false
                        return editor.commands.togglePromptSnippetExpanded()
                    },
                    
                    'Enter': ({ editor }) => {
                        if (!editor.isActive('promptSnippet')) return false

                        const { state } = editor
                        const { $from } = state.selection
                        const snippetAncestor = findAncestor($from, 'promptSnippet')
                        if (!snippetAncestor) return false

                        const { node: snippet, depth: snippetDepth } = snippetAncestor

                        if (isPromptSnippetEmpty(snippet)) {
                            const listAncestor = findAncestor($from, 'promptSnippetList')
                            const snippetStart = $from.before(snippetDepth)
                            const snippetEnd = $from.after(snippetDepth)

                            // Handle orphaned snippets (no parent list)
                            if (!listAncestor) {
                                return editor.chain()
                                    .deleteRange({ from: snippetStart, to: snippetEnd })
                                    .insertContentAt(snippetStart, { type: 'paragraph' })
                                    .setTextSelection(snippetStart + 1)
                                    .run()
                            }

                            const { node: list, depth: listDepth } = listAncestor
                            const listStart = $from.before(listDepth)
                            const listEnd = $from.after(listDepth)

                            if (list.childCount === 1) {
                                return editor.chain()
                                    .deleteRange({ from: listStart, to: listEnd })
                                    .insertContentAt(listStart, { type: 'paragraph' })
                                    .setTextSelection(listStart + 1)
                                    .run()
                            } else {
                                const snippetSize = snippetEnd - snippetStart
                                const newListEnd = listEnd - snippetSize
                                return editor.chain()
                                    .deleteRange({ from: snippetStart, to: snippetEnd })
                                    .insertContentAt(newListEnd, { type: 'paragraph' })
                                    .setTextSelection(newListEnd + 1)
                                    .run()
                            }
                        }

                        const titleAncestor = findAncestor($from, 'promptSnippetTitle')
                        const bodyAncestor = findAncestor($from, 'promptSnippetBody')
                        
                        if (titleAncestor) {
                            const snippetStart = $from.before(snippetDepth)
                            let bodyPos = null
                            let offset = 1
                            snippet.forEach(child => {
                                if (child.type.name === 'promptSnippetTitle') {
                                    offset += child.nodeSize
                                } else if (child.type.name === 'promptSnippetBody') {
                                    bodyPos = snippetStart + offset + 1
                                }
                            })
                            
                            if (bodyPos) {
                                return editor.commands.setTextSelection(bodyPos)
                            }
                        } else if (bodyAncestor) {
                            const pos = $from.before(snippetDepth)
                            const insertPos = $from.after(snippetDepth)
                            
                            editor.view.dispatch(
                                editor.state.tr.setNodeMarkup(pos, undefined, {
                                    ...snippet.attrs,
                                    expanded: false
                                })
                            )
                            
                            return editor.chain()
                                .insertContentAt(insertPos, createPromptSnippet(state.schema).toJSON())
                                .setTextSelection(insertPos + 2)
                                .run()
                        }
                        
                        return false
                    },
                    
                    'Tab': ({ editor }) => {
                        if (!editor.isActive('promptSnippet')) return false
                        
                        const { state } = editor
                        const { $from } = state.selection
                        const titleAncestor = findAncestor($from, 'promptSnippetTitle')
                        if (!titleAncestor) return false
                        
                        const snippetDepth = titleAncestor.depth - 1
                        const snippet = $from.node(snippetDepth)
                        const snippetStart = $from.before(snippetDepth)
                        
                        let bodyPos = null
                        let offset = 1
                        snippet.forEach(child => {
                            if (child.type.name === 'promptSnippetTitle') {
                                offset += child.nodeSize
                            } else if (child.type.name === 'promptSnippetBody') {
                                bodyPos = snippetStart + offset + 1
                            }
                        })
                        
                        if (bodyPos) {
                            return editor.commands.setTextSelection(bodyPos)
                        }
                        return false
                    },
                    
                    'Shift-Tab': ({ editor }) => {
                        if (!editor.isActive('promptSnippet')) return false
                        
                        const { $from } = editor.state.selection
                        const bodyAncestor = findAncestor($from, 'promptSnippetBody')
                        if (!bodyAncestor) return false
                        
                        const snippetStart = $from.before(bodyAncestor.depth - 1)
                        return editor.commands.setTextSelection(snippetStart + 2)
                    },
                    
                    'Backspace': ({ editor }) => {
                        if (!editor.isActive('promptSnippet')) return false

                        const { selection, selection: { $from } } = editor.state
                        if (!selection.empty || $from.parentOffset !== 0) return false

                        const titleAncestor = findAncestor($from, 'promptSnippetTitle')
                        if (!titleAncestor) return false

                        const snippetDepth = titleAncestor.depth - 1
                        const snippet = $from.node(snippetDepth)
                        if (!isPromptSnippetEmpty(snippet)) return false

                        const listAncestor = findAncestor($from, 'promptSnippetList')
                        const snippetStart = $from.before(snippetDepth)
                        const snippetEnd = $from.after(snippetDepth)

                        // Handle orphaned snippets (no parent list)
                        if (!listAncestor) {
                            return editor.chain()
                                .deleteRange({ from: snippetStart, to: snippetEnd })
                                .insertContentAt(snippetStart, { type: 'paragraph' })
                                .setTextSelection(snippetStart + 1)
                                .run()
                        }

                        const { node: list, depth: listDepth } = listAncestor
                        const listStart = $from.before(listDepth)
                        const listEnd = $from.after(listDepth)

                        if (list.childCount === 1) {
                            return editor.chain()
                                .deleteRange({ from: listStart, to: listEnd })
                                .insertContentAt(listStart, { type: 'paragraph' })
                                .setTextSelection(listStart + 1)
                                .run()
                        } else {
                            const snippetSize = snippetEnd - snippetStart
                            const newListEnd = listEnd - snippetSize
                            return editor.chain()
                                .deleteRange({ from: snippetStart, to: snippetEnd })
                                .insertContentAt(newListEnd, { type: 'paragraph' })
                                .setTextSelection(newListEnd + 1)
                                .run()
                        }
                    },
                    
                    'Mod-Enter': ({ editor }) => {
                        if (!editor.isActive('promptSnippet')) return false
                        return editor.commands.togglePromptSnippetExpanded()
                    }
                }
            },
            
            addNodeView() {
                return ({ node, getPos, editor }) => {
                    const dom = document.createElement('div')
                    
                    function getClassName(n) {
                        const classes = ['prompt-snippet']
                        if (!n.attrs.expanded) classes.push('is-collapsed')
                        if (n.attrs.completed) classes.push('is-completed')
                        return classes.join(' ')
                    }
                    
                    dom.className = getClassName(node)
                    dom.setAttribute('data-type', 'prompt-snippet')
                    
                    const checkbox = document.createElement('div')
                    checkbox.className = 'prompt-snippet-checkbox'
                    checkbox.setAttribute('contenteditable', 'false')
                    
                    checkbox.addEventListener('mousedown', (e) => {
                        e.preventDefault()
                        e.stopPropagation()
                        const pos = getPos()
                        if (typeof pos === 'number') {
                            editor.commands.togglePromptSnippetCompleted(pos)
                        }
                    })
                    
                    const content = document.createElement('div')
                    content.className = 'prompt-snippet-content'
                    
                    const preview = document.createElement('div')
                    preview.className = 'prompt-snippet-preview'
                    
                    const feedback = document.createElement('div')
                    feedback.className = 'prompt-snippet-copy-feedback'
                    feedback.textContent = 'Copied!'
                    
                    function createButton(iconHtml, label, className = '') {
                        const btn = document.createElement('button')
                        btn.className = `prompt-snippet-action ${className}`.trim()
                        btn.type = 'button'
                        btn.innerHTML = `<span class="prompt-snippet-action-icon">${iconHtml}</span>${label}`
                        return btn
                    }
                    
                    const actions = document.createElement('div')
                    actions.className = 'prompt-snippet-actions'
                    actions.setAttribute('contenteditable', 'false')

                    const doneBtn = createButton('✓', 'Done', 'prompt-snippet-action--done')
                    const deleteBtn = createButton('×', 'Delete', 'prompt-snippet-action--delete')

                    doneBtn.addEventListener('mousedown', (e) => {
                        e.preventDefault()
                        e.stopPropagation()
                        const pos = getPos()
                        if (typeof pos === 'number') {
                            const currentNode = editor.state.doc.nodeAt(pos)
                            if (currentNode && currentNode.type.name === 'promptSnippet') {
                                editor.view.dispatch(
                                    editor.state.tr.setNodeMarkup(pos, undefined, {
                                        ...currentNode.attrs,
                                        expanded: false
                                    })
                                )
                            }
                        }
                    })

                    deleteBtn.addEventListener('mousedown', (e) => {
                        e.preventDefault()
                        e.stopPropagation()
                        const pos = getPos()
                        if (typeof pos === 'number') {
                            editor.commands.deletePromptSnippetAt(pos)
                        }
                    })
                    
                    actions.appendChild(doneBtn)
                    actions.appendChild(deleteBtn)
                    
                    const previewActions = document.createElement('div')
                    previewActions.className = 'prompt-snippet-preview-actions'
                    previewActions.setAttribute('contenteditable', 'false')
                    
                    const editBtn = createButton('✎', 'Edit')
                    const previewCopyBtn = createButton('⧉', 'Copy')
                    
                    editBtn.addEventListener('mousedown', (e) => {
                        e.preventDefault()
                        e.stopPropagation()
                        const pos = getPos()
                        if (typeof pos === 'number') {
                            editor.commands.expandPromptSnippetAt(pos)
                        }
                    })
                    
                    previewCopyBtn.addEventListener('mousedown', (e) => {
                        e.preventDefault()
                        e.stopPropagation()
                        const pos = getPos()
                        if (typeof pos === 'number') {
                            const currentNode = editor.state.doc.nodeAt(pos)
                            if (currentNode && currentNode.type.name === 'promptSnippet') {
                                let titleText = ''
                                let bodyText = ''
                                currentNode.forEach(child => {
                                    if (child.type.name === 'promptSnippetTitle') {
                                        titleText = child.textContent
                                    } else if (child.type.name === 'promptSnippetBody') {
                                        bodyText = child.textContent
                                    }
                                })
                                // Copy title on first line, description on second line
                                const textToCopy = titleText && bodyText
                                    ? `${titleText}\n${bodyText}`
                                    : titleText || bodyText
                                if (textToCopy) {
                                    navigator.clipboard.writeText(textToCopy)
                                    feedback.classList.add('visible')
                                    setTimeout(() => feedback.classList.remove('visible'), 1500)
                                }
                            }
                        }
                    })
                    
                    previewActions.appendChild(editBtn)
                    previewActions.appendChild(previewCopyBtn)
                    
                    function updatePreview(snippetNode) {
                        let titleText = ''
                        let bodyText = ''
                        snippetNode.forEach(child => {
                            if (child.type.name === 'promptSnippetTitle') {
                                titleText = child.textContent
                            } else if (child.type.name === 'promptSnippetBody') {
                                bodyText = child.textContent
                            }
                        })
                        
                        preview.innerHTML = ''
                        
                        const previewTitle = document.createElement('div')
                        previewTitle.className = 'prompt-snippet-preview-title'
                        previewTitle.textContent = titleText || 'Untitled Snippet'
                        
                        const previewBody = document.createElement('div')
                        previewBody.className = 'prompt-snippet-preview-body'
                        previewBody.textContent = bodyText.length > 150 
                            ? bodyText.substring(0, 150) + '...' 
                            : bodyText || 'Empty snippet'
                        
                        preview.appendChild(previewTitle)
                        preview.appendChild(previewBody)
                    }
                    
                    updatePreview(node)

                    // Click anywhere on collapsed snippet to copy
                    dom.addEventListener('click', (e) => {
                        // Only trigger if collapsed and not clicking on a button
                        const pos = getPos()
                        if (typeof pos !== 'number') return

                        const currentNode = editor.state.doc.nodeAt(pos)
                        if (!currentNode || currentNode.type.name !== 'promptSnippet') return
                        if (currentNode.attrs.expanded) return // Don't copy when expanded

                        // Don't copy if clicking on buttons
                        if (e.target.closest('.prompt-snippet-action')) return
                        if (e.target.closest('.prompt-snippet-checkbox')) return

                        e.preventDefault()
                        e.stopPropagation()

                        let titleText = ''
                        let bodyText = ''
                        currentNode.forEach(child => {
                            if (child.type.name === 'promptSnippetTitle') {
                                titleText = child.textContent
                            } else if (child.type.name === 'promptSnippetBody') {
                                bodyText = child.textContent
                            }
                        })

                        const textToCopy = titleText && bodyText
                            ? `${titleText}\n${bodyText}`
                            : titleText || bodyText

                        if (textToCopy) {
                            navigator.clipboard.writeText(textToCopy)
                            feedback.classList.add('visible')
                            setTimeout(() => feedback.classList.remove('visible'), 1500)
                        }
                    })

                    // Right-click context menu for delete
                    dom.addEventListener('contextmenu', (e) => {
                        e.preventDefault()
                        e.stopPropagation()

                        const pos = getPos()
                        if (typeof pos !== 'number') return

                        // Remove any existing context menu
                        const existingMenu = document.querySelector('.prompt-snippet-context-menu')
                        if (existingMenu) existingMenu.remove()

                        // Create context menu
                        const menu = document.createElement('div')
                        menu.className = 'prompt-snippet-context-menu'
                        menu.style.cssText = `
                            position: fixed;
                            left: ${e.clientX}px;
                            top: ${e.clientY}px;
                            background: var(--editor-bg, #fff);
                            border: 1px solid var(--border-color, #e0e0e0);
                            border-radius: 6px;
                            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
                            padding: 4px 0;
                            z-index: 9999;
                            min-width: 120px;
                            font-family: -apple-system, BlinkMacSystemFont, "SF Pro Text", "Helvetica Neue", sans-serif;
                        `

                        const deleteItem = document.createElement('div')
                        deleteItem.textContent = 'Delete Snippet'
                        deleteItem.style.cssText = `
                            padding: 8px 12px;
                            cursor: pointer;
                            color: #d32f2f;
                            font-size: 13px;
                            font-weight: 400;
                        `
                        deleteItem.addEventListener('mouseenter', () => {
                            deleteItem.style.background = 'rgba(211, 47, 47, 0.1)'
                        })
                        deleteItem.addEventListener('mouseleave', () => {
                            deleteItem.style.background = 'transparent'
                        })
                        deleteItem.addEventListener('click', () => {
                            menu.remove()
                            editor.commands.deletePromptSnippetAt(pos)
                        })

                        menu.appendChild(deleteItem)
                        document.body.appendChild(menu)

                        // Close menu when clicking elsewhere
                        const closeMenu = (evt) => {
                            if (!menu.contains(evt.target)) {
                                menu.remove()
                                document.removeEventListener('click', closeMenu)
                                document.removeEventListener('contextmenu', closeMenu)
                            }
                        }
                        // Delay adding listener to avoid immediate trigger
                        setTimeout(() => {
                            document.addEventListener('click', closeMenu)
                            document.addEventListener('contextmenu', closeMenu)
                        }, 0)
                    })

                    dom.appendChild(checkbox)
                    dom.appendChild(content)
                    dom.appendChild(preview)
                    dom.appendChild(actions)
                    dom.appendChild(previewActions)
                    dom.appendChild(feedback)
                    
                    return {
                        dom,
                        contentDOM: content,
                        update: (updatedNode) => {
                            if (updatedNode.type.name !== 'promptSnippet') return false
                            dom.className = getClassName(updatedNode)
                            updatePreview(updatedNode)
                            return true
                        }
                    }
                }
            }
        })
        
        const PromptSnippetTitle = Node.create({
            name: 'promptSnippetTitle',
            group: 'block',
            content: 'inline*',
            defining: true,
            parseHTML() { return [{ tag: 'div[data-type="prompt-snippet-title"]' }] },
            renderHTML({ HTMLAttributes }) {
                return ['div', mergeAttributes(HTMLAttributes, { 
                    'data-type': 'prompt-snippet-title',
                    'class': 'prompt-snippet-title'
                }), 0]
            }
        })
        
        const PromptSnippetBody = Node.create({
            name: 'promptSnippetBody',
            group: 'block',
            content: 'inline*',
            parseHTML() { return [{ tag: 'div[data-type="prompt-snippet-body"]' }] },
            renderHTML({ HTMLAttributes }) {
                return ['div', mergeAttributes(HTMLAttributes, { 
                    'data-type': 'prompt-snippet-body',
                    'class': 'prompt-snippet-body'
                }), 0]
            }
        })
        
        // ============================================
        // Initialize Yjs for a document
        // ============================================
        function initializeYjs(documentId) {
            // Cleanup previous instance
            if (wsProvider) {
                sendToSwift({ type: 'debug', message: 'Destroying previous wsProvider' })
                wsProvider.destroy()
            }
            if (indexeddbProvider) {
                // Log current content before destroying
                if (ydoc) {
                    const content = ydoc.getXmlFragment('content')
                    sendToSwift({ type: 'debug', message: `Destroying IndexedDB provider. Current content: ${content.length} items` })
                }
                indexeddbProvider.destroy()
            }
            if (ydoc) {
                sendToSwift({ type: 'debug', message: 'Destroying previous ydoc' })
                ydoc.destroy()
            }
            
            DOCUMENT_ID = documentId
            const roomName = `doc-${documentId}`
            
            sendToSwift({ type: 'debug', message: `Initializing Yjs for room: ${roomName}` })
            
            // Create new Yjs document
            ydoc = new Y.Doc()
            
            // Initialize metadata with defaults if empty
            const meta = ydoc.getMap('meta')
            
            // Local persistence (IndexedDB) for offline support
            indexeddbProvider = new IndexeddbPersistence(roomName, ydoc)
            
            // Track content changes (reduced logging - only log significant changes)
            let lastContentLength = 0
            ydoc.on('update', (update, origin) => {
                const content = ydoc.getXmlFragment('content')
                // Only log if content length changed significantly
                if (content.length !== lastContentLength) {
                    lastContentLength = content.length
                    // Uncomment for debugging: sendToSwift({ type: 'debug', message: `Yjs content: ${content.length} items` })
                }
            })
            
            indexeddbProvider.on('synced', () => {
                sendToSwift({ type: 'debug', message: 'IndexedDB synced' })
                
                // Initialize metadata defaults after loading from IndexedDB
                if (!meta.get('createdAt')) {
                    ydoc.transact(() => {
                        meta.set('createdAt', Date.now())
                        meta.set('updatedAt', Date.now())
                        meta.set('isDeleted', false)
                        meta.set('isFavorite', false)
                        meta.set('isPinned', false)
                    })
                }
                
                const content = ydoc.getXmlFragment('content')
                sendToSwift({ type: 'debug', message: `IndexedDB: Content fragment length: ${content.length}` })
                
                // Debug: log what's in the fragment
                try {
                    const fragmentJSON = content.toJSON()
                    sendToSwift({ type: 'debug', message: `IndexedDB content: ${JSON.stringify(fragmentJSON).slice(0, 200)}` })
                } catch (e) {
                    sendToSwift({ type: 'debug', message: `IndexedDB content parse error: ${e.message}` })
                }
            })
            
            // WebSocket connection to PartyKit using y-partykit provider
            sendToSwift({ type: 'debug', message: `Connecting to PartyKit host: ${PARTYKIT_HOST}, room: ${roomName}` })
            
            wsProvider = new YPartyKitProvider(PARTYKIT_HOST, roomName, ydoc, {
                connect: true
            })
            
            // Connection status
            wsProvider.on('status', ({ status }) => {
                sendToSwift({ type: 'debug', message: `WebSocket status: ${status}` })
                updateConnectionStatus(status)
                
                sendToSwift({
                    type: 'connectionStatus',
                    status: status,
                    documentId: documentId
                })
            })
            
            // Log when WebSocket syncs (data from server)
            wsProvider.on('sync', (isSynced) => {
                sendToSwift({ type: 'debug', message: `WebSocket sync: ${isSynced}` })
                if (isSynced) {
                    updateConnectionStatus('connected')
                    const content = ydoc.getXmlFragment('content')
                    sendToSwift({ type: 'debug', message: `Server sync: Content fragment length: ${content.length}` })
                    try {
                        const fragmentJSON = content.toJSON()
                        sendToSwift({ type: 'debug', message: `Server content: ${JSON.stringify(fragmentJSON).slice(0, 200)}` })
                    } catch (e) {
                        sendToSwift({ type: 'debug', message: `Server content parse error: ${e.message}` })
                    }
                }
            })
            
            // Listen for metadata changes (for native app)
            meta.observe((event) => {
                sendToSwift({
                    type: 'metaChange',
                    meta: meta.toJSON()
                })
            })
            
            return ydoc
        }
        
        // ============================================
        // Initialize Editor
        // ============================================
        function initializeEditor(ydoc) {
            sendToSwift({ type: 'debug', message: 'Creating TipTap editor with Yjs...' })
            
            // Cleanup previous editor if exists
            if (editor) {
                sendToSwift({ type: 'debug', message: 'Destroying previous editor instance' })
                editor.destroy()
                editor = null
            }
            
            const editorElement = document.getElementById('editor')
            if (!editorElement) {
                sendToSwift({ type: 'debug', message: 'ERROR: Editor element not found!' })
                return
            }
            
            sendToSwift({ type: 'debug', message: `wsProvider exists: ${!!wsProvider}, ydoc exists: ${!!ydoc}` })
            
            try {
                // Try minimal extensions first to test Collaboration
                const useCollaboration = true // Toggle for testing
                
                const extensions = [
                    StarterKit.configure({
                        heading: { levels: [1, 2, 3] },
                        history: useCollaboration ? false : undefined // Disable history when using Collaboration
                    }),
                    Placeholder.configure({ 
                        placeholder: ({ node }) => {
                            if (node.type.name === 'taskCardTitle') return 'What needs to be done?'
                            if (node.type.name === 'taskCardDescription') return 'Add notes...'
                            if (node.type.name === 'promptSnippetTitle') return 'Snippet title...'
                            if (node.type.name === 'promptSnippetBody') return 'Write your prompt here...'
                            return 'Start writing...'
                        },
                        includeChildren: true,
                        showOnlyCurrent: false
                    }),
                    Underline,
                    Link.configure({ openOnClick: false, HTMLAttributes: { class: 'link' } }),
                    TaskList,
                    TaskItem.configure({ nested: true }),
                    // Custom Task Card extensions
                    TaskCardList,
                    TaskCard,
                    TaskCardTitle,
                    TaskCardDescription,
                    // Custom Prompt Snippet extensions
                    PromptSnippetList,
                    PromptSnippet,
                    PromptSnippetTitle,
                    PromptSnippetBody,
                    Image.configure({ HTMLAttributes: { class: 'image' } }),
                    Table.configure({ resizable: true }),
                    TableRow,
                    TableHeader,
                    TableCell,
                    Highlight.configure({ multicolor: true }),
                    TextAlign.configure({ types: ['heading', 'paragraph'] }),
                    Subscript,
                    Superscript,
                    TextStyle,
                ]
                
                // Add Collaboration if enabled
                if (useCollaboration) {
                    const fragment = ydoc.getXmlFragment('content')
                    sendToSwift({ type: 'debug', message: `Adding Collaboration extension... Yjs fragment length: ${fragment.length}` })

                    // Debug: log Yjs fragment structure
                    try {
                        sendToSwift({ type: 'debug', message: `Yjs fragment type: ${fragment.constructor.name}` })
                    } catch (e) {
                        sendToSwift({ type: 'debug', message: `Yjs fragment error: ${e.message}` })
                    }

                    // Pass fragment directly instead of document+field
                    // This avoids internal document.getXmlFragment call that might use different Yjs instance
                    extensions.push(
                        Collaboration.configure({
                            fragment: fragment
                        })
                    )

                    // Add CollaborationCursor for presence indicators (shows other users' cursors)
                    if (wsProvider && CollaborationCursor) {
                        sendToSwift({ type: 'debug', message: `Adding CollaborationCursor with user: ${USER_NAME}, color: ${USER_COLOR}` })
                        extensions.push(
                            CollaborationCursor.configure({
                                provider: wsProvider,
                                user: {
                                    name: USER_NAME,
                                    color: USER_COLOR
                                }
                            })
                        )
                    }
                }
                
                sendToSwift({ type: 'debug', message: 'Creating Editor instance...' })
                
                editor = new Editor({
                    element: editorElement,
                    extensions: extensions,
                    editable: true,
                    autofocus: 'end',
                    // Note: Don't set content when using Collaboration - Yjs provides it
                    
                    onCreate: ({ editor }) => {
                        sendToSwift({ type: 'debug', message: `Editor created! Editable: ${editor.isEditable}` })

                        // Heal any corrupted snippets after document loads
                        setTimeout(() => {
                            const result = healCorruptedSnippets(editor)
                            if (result.removed > 0) {
                                sendToSwift({ type: 'debug', message: `Auto-healed ${result.removed} corrupted snippets on load` })
                            }
                        }, 500)  // Give Yjs time to fully sync
                    },
                    
                    onUpdate: ({ editor }) => {
                        // Update Yjs metadata (for server sync)
                        if (ydoc) {
                            const meta = ydoc.getMap('meta')
                            ydoc.transact(() => {
                                meta.set('updatedAt', Date.now())
                                
                                // Extract title from first line/heading
                                const firstBlock = editor.state.doc.firstChild
                                if (firstBlock) {
                                    const title = firstBlock.textContent.trim().slice(0, 100)
                                    if (title && title !== meta.get('title')) {
                                        meta.set('title', title)
                                    }
                                }
                            })
                        }
                        
                        // Send content change to native app (for document list update and task extraction)
                        const text = editor.getText()
                        const firstLine = text.split('\n')[0]?.trim().slice(0, 100) || ''
                        
                        sendToSwift({
                            type: 'contentChange',
                            html: editor.getHTML(),
                            json: editor.getJSON(),  // For task extraction
                            text: text,
                            title: firstLine,  // For document list
                        });
                    },
                
                    onSelectionUpdate: ({ editor }) => {
                        sendToSwift({ type: 'selectionChange', state: getState() });
                    }
                });
                
                window.editor = editor
                sendToSwift({ type: 'debug', message: `Editor instance created successfully, editable: ${editor.isEditable}` })
                
                // Focus the editor and handle new document initialization
                setTimeout(() => {
                    const isEmpty = editor.isEmpty
                    sendToSwift({ type: 'debug', message: `Editor isEmpty: ${isEmpty}, HTML: ${editor.getHTML().slice(0, 100)}` })
                    
                    // For new/empty documents, start with a Title (H1) instead of body paragraph
                    if (isEmpty) {
                        editor.chain()
                            .setContent('<h1></h1>')
                            .focus('end')
                            .run()
                        sendToSwift({ type: 'debug', message: 'Initialized new document with Title format' })
                    } else {
                        editor.commands.focus('end')
                    }
                    sendToSwift({ type: 'debug', message: 'Editor focused' })
                }, 100)
                
                // Task action bar positioning logic
                let previousTaskCardPos = null
                
                function updateTaskActionBar(editor) {
                    const { state } = editor
                    const { $from } = state.selection
                    
                    // Find if we're inside a task card
                    let currentTaskCardPos = null
                    for (let d = $from.depth; d > 0; d--) {
                        const node = $from.node(d)
                        if (node.type.name === 'taskCard') {
                            currentTaskCardPos = $from.before(d)
                            break
                        }
                    }
                    
                    // Position and show/hide floating action bar
                    const actionBar = document.getElementById('task-action-bar')
                    if (actionBar) {
                        if (currentTaskCardPos !== null) {
                            const sel = window.getSelection()
                            if (sel && sel.anchorNode) {
                                const focusedCard = sel.anchorNode.nodeType === 1 
                                    ? sel.anchorNode.closest('.task-card')
                                    : sel.anchorNode.parentElement?.closest('.task-card')
                                if (focusedCard) {
                                    const cardRect = focusedCard.getBoundingClientRect()
                                    actionBar.style.top = (cardRect.bottom - 20) + 'px'
                                    actionBar.style.right = (window.innerWidth - cardRect.right + 12) + 'px'
                                    actionBar.classList.add('visible')
                                    actionBar.dataset.taskCardPos = currentTaskCardPos
                                } else {
                                    actionBar.classList.remove('visible')
                                }
                            } else {
                                actionBar.classList.remove('visible')
                            }
                        } else {
                            actionBar.classList.remove('visible')
                        }
                    }
                    
                    previousTaskCardPos = currentTaskCardPos
                }
                
                // Hook into selection changes
                editor.on('selectionUpdate', () => updateTaskActionBar(editor))
                
                // Update action bar position on scroll
                const scrollContainer = document.getElementById('editor')
                if (scrollContainer) {
                    scrollContainer.addEventListener('scroll', () => {
                        const actionBar = document.getElementById('task-action-bar')
                        if (actionBar && actionBar.classList.contains('visible')) {
                            updateTaskActionBar(editor)
                        }
                    }, { passive: true })
                }
                
                // Set up floating action bar click handlers
                const actionBar = document.getElementById('task-action-bar')
                if (actionBar) {
                    actionBar.addEventListener('mousedown', (e) => {
                        e.preventDefault()
                        e.stopPropagation()
                        
                        const action = e.target.closest('[data-action]')?.dataset.action
                        if (!action) return
                        
                        const taskCardPos = parseInt(actionBar.dataset.taskCardPos, 10)
                        if (isNaN(taskCardPos)) return
                        
                        if (action === 'new-task') {
                            editor.commands.insertTaskCard()
                        } else if (action === 'description') {
                            editor.commands.setTextSelection(taskCardPos + 2)
                            setTimeout(() => {
                                const { state } = editor
                                const { $from } = state.selection
                                const taskCard = $from.node($from.depth - 1)
                                const taskCardStart = $from.before($from.depth - 1)
                                
                                let hasDescription = false
                                let descPos = null
                                let offset = 1
                                if (taskCard) {
                                    taskCard.forEach(child => {
                                        if (child.type.name === 'taskCardTitle') {
                                            offset += child.nodeSize
                                        } else if (child.type.name === 'taskCardDescription') {
                                            hasDescription = true
                                            descPos = taskCardStart + offset + 1
                                        }
                                    })
                                }
                                
                                if (hasDescription && descPos) {
                                    editor.commands.setTextSelection(descPos)
                                } else {
                                    const insertPos = $from.after($from.depth - 1) - 1
                                    const newDesc = state.schema.nodes.taskCardDescription.create()
                                    editor.chain()
                                        .insertContentAt(insertPos, newDesc.toJSON())
                                        .setTextSelection(insertPos + 1)
                                        .run()
                                }
                            }, 10)
                        } else if (action === 'delete') {
                            // Replicate the Enter key behavior for deleting empty task cards
                            // Position cursor at start of task card and simulate Enter on empty
                            editor.commands.setTextSelection(taskCardPos + 2)
                            
                            const { state } = editor
                            const { $from } = state.selection
                            const taskAncestor = findAncestor($from, 'taskCard')
                            if (!taskAncestor) return
                            
                            const { depth: taskCardDepth } = taskAncestor
                            const listAncestor = findAncestor($from, 'taskCardList')
                            if (!listAncestor) return
                            
                            const { node: list, depth: listDepth } = listAncestor
                            const listEnd = $from.after(listDepth)
                            
                            // Hide action bar immediately
                            actionBar.classList.remove('visible')
                            
                            if (list.childCount === 1) {
                                // Only task in list - delete whole list
                                const listStart = $from.before(listDepth)
                                editor.chain()
                                    .deleteRange({ from: listStart, to: listEnd })
                                    .insertContentAt(listStart, { type: 'paragraph' })
                                    .setTextSelection(listStart + 1)
                                    .run()
                            } else {
                                // Multiple tasks - delete just this one
                                const taskStart = $from.before(taskCardDepth)
                                const taskEnd = $from.after(taskCardDepth)
                                editor.chain()
                                    .deleteRange({ from: taskStart, to: taskEnd })
                                    .insertContentAt(listEnd - (taskEnd - taskStart), { type: 'paragraph' })
                                    .setTextSelection(listEnd - (taskEnd - taskStart) + 1)
                                    .run()
                            }
                        }
                    })
                }
                
            } catch (err) {
                sendToSwift({ type: 'debug', message: `ERROR creating editor: ${err.message}` })
                console.error('Editor creation error:', err)
                return
            }
            
            // ============================================
            // Editor Bridge (API for native app)
            // ============================================
            window.editorBridge = {
                // Initialize with document ID (called by native app)
                initDocument: (documentId, config = {}) => {
                    if (config.partyKitHost) PARTYKIT_HOST = config.partyKitHost
                    if (config.userId) USER_ID = config.userId
                    if (config.userName) USER_NAME = config.userName
                    if (config.userColor) USER_COLOR = config.userColor
                    
                    initializeYjs(documentId)
                    initializeEditor(ydoc)
                },
                
                // Get/set metadata (uses Yjs Map)
                getMeta: () => {
                    if (!ydoc) return {}
                    return ydoc.getMap('meta').toJSON()
                },
                
                setMeta: (key, value) => {
                    if (!ydoc) return
                    const meta = ydoc.getMap('meta')
                    ydoc.transact(() => {
                        meta.set(key, value)
                        meta.set('updatedAt', Date.now())
                    })
                },
                
                // Trash document (sets metadata)
                moveToTrash: () => {
                    if (!ydoc) return
                    const meta = ydoc.getMap('meta')
                    ydoc.transact(() => {
                        meta.set('isDeleted', true)
                        meta.set('deletedAt', Date.now())
                        meta.set('updatedAt', Date.now())
                    })
                    sendToSwift({ type: 'debug', message: 'Document moved to trash via Yjs' })
                },
                
                // Restore from trash
                restore: () => {
                    if (!ydoc) return
                    const meta = ydoc.getMap('meta')
                    ydoc.transact(() => {
                        meta.set('isDeleted', false)
                        meta.set('deletedAt', null)
                        meta.set('updatedAt', Date.now())
                    })
                    sendToSwift({ type: 'debug', message: 'Document restored via Yjs' })
                },
                
                // Set workspace
                setWorkspace: (workspaceId) => {
                    if (!ydoc) return
                    const meta = ydoc.getMap('meta')
                    ydoc.transact(() => {
                        meta.set('workspaceId', workspaceId)
                        meta.set('updatedAt', Date.now())
                    })
                },
                
                // Toggle favorite
                toggleFavorite: () => {
                    if (!ydoc) return
                    const meta = ydoc.getMap('meta')
                    ydoc.transact(() => {
                        meta.set('isFavorite', !meta.get('isFavorite'))
                        meta.set('updatedAt', Date.now())
                    })
                },
                
                // Toggle pinned
                togglePinned: () => {
                    if (!ydoc) return
                    const meta = ydoc.getMap('meta')
                    ydoc.transact(() => {
                        meta.set('isPinned', !meta.get('isPinned'))
                        meta.set('updatedAt', Date.now())
                    })
                },
                
                // Set tags
                setTags: (tags) => {
                    if (!ydoc) return
                    const meta = ydoc.getMap('meta')
                    ydoc.transact(() => {
                        meta.set('tags', tags)
                        meta.set('updatedAt', Date.now())
                    })
                },
                
                // Legacy content methods (for backwards compatibility)
                setContent: (html) => {
                    if (editor) editor.commands.setContent(html || '<h1></h1>');
                },
                setContentJSON: (jsonStr) => { 
                    if (jsonStr && editor) {
                        try {
                            const json = typeof jsonStr === 'string' ? JSON.parse(jsonStr) : jsonStr;
                            editor.commands.setContent(json);
                        } catch (e) {
                            console.error('Failed to parse JSON content:', e);
                        }
                    }
                },
                getContent: () => editor?.getHTML() || '',
                getContentJSON: () => JSON.stringify(editor?.getJSON() || {}),
                getText: () => editor?.getText() || '',
                
                // Formatting commands
                toggleBold: () => editor?.chain().focus().toggleBold().run(),
                toggleItalic: () => editor?.chain().focus().toggleItalic().run(),
                toggleUnderline: () => editor?.chain().focus().toggleUnderline().run(),
                toggleStrike: () => editor?.chain().focus().toggleStrike().run(),
                toggleCode: () => editor?.chain().focus().toggleCode().run(),
                toggleHighlight: () => editor?.chain().focus().toggleHighlight().run(),
                setHighlightColor: (color) => editor?.chain().focus().toggleHighlight({ color }).run(),
                toggleSubscript: () => editor?.chain().focus().toggleSubscript().run(),
                toggleSuperscript: () => editor?.chain().focus().toggleSuperscript().run(),
                
                setHeading: (level) => {
                    if (!editor) return
                    if (level === 0) editor.chain().focus().setParagraph().run();
                    else editor.chain().focus().toggleHeading({ level }).run();
                },
                toggleHeading: (level) => {
                    if (!editor) return
                    if (level === 0) editor.chain().focus().setParagraph().run();
                    else editor.chain().focus().toggleHeading({ level }).run();
                },
                toggleHeading1: () => editor?.chain().focus().toggleHeading({ level: 1 }).run(),
                toggleHeading2: () => editor?.chain().focus().toggleHeading({ level: 2 }).run(),
                toggleHeading3: () => editor?.chain().focus().toggleHeading({ level: 3 }).run(),
                
                toggleBulletList: () => editor?.chain().focus().toggleBulletList().run(),
                toggleOrderedList: () => editor?.chain().focus().toggleOrderedList().run(),
                toggleTaskList: () => editor?.chain().focus().toggleTaskList().run(),
                toggleBlockquote: () => editor?.chain().focus().toggleBlockquote().run(),
                toggleCodeBlock: () => editor?.chain().focus().toggleCodeBlock().run(),
                setHorizontalRule: () => editor?.chain().focus().setHorizontalRule().run(),
                
                setLink: (url) => {
                    if (!editor) return
                    if (url) editor.chain().focus().setLink({ href: url }).run();
                    else editor.chain().focus().unsetLink().run();
                },
                unsetLink: () => {
                    if (editor) editor.chain().focus().unsetLink().run();
                },

                insertImage: (src, alt, title) => {
                    if (src && editor) editor.chain().focus().setImage({ src, alt: alt || '', title: title || '' }).run();
                },
                
                insertTable: () => editor?.chain().focus().insertTable({ rows: 3, cols: 3, withHeaderRow: true }).run(),
                deleteTable: () => editor?.chain().focus().deleteTable().run(),
                addColumnBefore: () => editor?.chain().focus().addColumnBefore().run(),
                addColumnAfter: () => editor?.chain().focus().addColumnAfter().run(),
                deleteColumn: () => editor?.chain().focus().deleteColumn().run(),
                addRowBefore: () => editor?.chain().focus().addRowBefore().run(),
                addRowAfter: () => editor?.chain().focus().addRowAfter().run(),
                deleteRow: () => editor?.chain().focus().deleteRow().run(),
                
                setTextAlign: (align) => editor?.chain().focus().setTextAlign(align).run(),

                undo: () => editor?.chain().focus().undo().run(),
                redo: () => editor?.chain().focus().redo().run(),
                
                // Task List (TipTap's built-in checkbox list)
                toggleTaskList: () => editor?.chain().focus().toggleTaskList().run(),
                
                // Task Card commands
                insertTaskCard: () => editor?.commands.insertTaskCard(),
                
                // Set task checked state by node index (called from Swift when toggling in task list)
                setTaskChecked: (nodeIndex, isChecked) => {
                    if (!editor) return false
                    
                    let currentIndex = 0
                    let found = false
                    
                    editor.state.doc.descendants((node, pos) => {
                        if (found) return false  // Stop traversal
                        if (node.type.name === 'taskCard') {
                            if (currentIndex === nodeIndex) {
                                editor.chain()
                                    .command(({ tr, dispatch }) => {
                                        if (dispatch) {
                                            tr.setNodeMarkup(pos, undefined, {
                                                ...node.attrs,
                                                checked: isChecked
                                            })
                                        }
                                        return true
                                    })
                                    .run()
                                found = true
                                return false  // Stop traversal
                            }
                            currentIndex++
                        }
                    })
                    
                    return found
                },
                toggleTaskCard: () => {
                    if (editor?.isActive('taskCard')) {
                        // Exit task card
                        const { $from } = editor.state.selection
                        const listAncestor = findAncestor($from, 'taskCardList')
                        if (listAncestor) {
                            const listStart = $from.before(listAncestor.depth)
                            const listEnd = $from.after(listAncestor.depth)
                            editor.chain()
                                .deleteRange({ from: listStart, to: listEnd })
                                .insertContentAt(listStart, { type: 'paragraph' })
                                .setTextSelection(listStart + 1)
                                .run()
                        }
                    } else {
                        editor?.commands.insertTaskCard()
                    }
                },
                toggleTaskCardChecked: () => editor?.commands.toggleTaskCardChecked(),
                
                // Prompt Snippet commands
                insertPromptSnippet: () => editor?.commands.insertPromptSnippet(),
                togglePromptSnippet: () => {
                    if (editor?.isActive('promptSnippet')) {
                        editor.commands.togglePromptSnippetExpanded()
                    } else {
                        editor?.commands.insertPromptSnippet()
                    }
                },
                togglePromptSnippetExpanded: () => editor?.commands.togglePromptSnippetExpanded(),
                copyPromptSnippet: () => editor?.commands.copyPromptSnippet(),

                // Heal corrupted snippets (checks structure, not just empty)
                healSnippets: () => {
                    if (!editor) return { healed: 0, removed: 0 }
                    return healCorruptedSnippets(editor)
                },

                // Debug: dump full document structure
                debugDocument: () => {
                    if (!editor) return 'No editor'

                    const { state } = editor
                    const nodes = []

                    state.doc.descendants((node, pos) => {
                        const info = {
                            type: node.type.name,
                            pos: pos,
                            size: node.nodeSize,
                            childCount: node.childCount,
                            text: node.isText ? node.text : (node.textContent?.slice(0, 50) || ''),
                            attrs: node.attrs
                        }
                        nodes.push(info)

                        // Extra detail for snippets
                        if (node.type.name === 'promptSnippet' || node.type.name === 'promptSnippetList') {
                            sendToSwift({ type: 'debug', message: `NODE: ${node.type.name} at ${pos}, size=${node.nodeSize}, children=${node.childCount}` })
                            node.forEach((child, offset) => {
                                sendToSwift({ type: 'debug', message: `  CHILD: ${child.type.name} at offset ${offset}, size=${child.nodeSize}` })
                            })
                        }
                    })

                    sendToSwift({ type: 'debug', message: `Document has ${nodes.length} nodes total` })

                    // Count snippets
                    const snippetLists = nodes.filter(n => n.type === 'promptSnippetList').length
                    const snippets = nodes.filter(n => n.type === 'promptSnippet').length
                    sendToSwift({ type: 'debug', message: `Found ${snippetLists} snippet lists, ${snippets} snippets` })

                    return { nodeCount: nodes.length, snippetLists, snippets }
                },

                focus: () => editor?.commands.focus(),
                blur: () => editor?.commands.blur(),
                getState: () => JSON.stringify(getState()),
                
                setThemeCSS: (css) => {
                    const el = document.getElementById('theme-styles');
                    if (el) el.textContent = css;
                },
                
                // Connection management
                disconnect: () => {
                    if (wsProvider) wsProvider.disconnect()
                },
                reconnect: () => {
                    if (wsProvider) wsProvider.connect()
                },
                getConnectionStatus: () => {
                    return wsProvider?.wsconnected ? 'connected' : 'disconnected'
                },

                // Remove all corrupted/empty snippet lists from the document
                // This syncs to server via Yjs, fixing corruption everywhere
                removeCorruptedSnippets: () => {
                    if (!editor) {
                        sendToSwift({ type: 'debug', message: 'No editor to clean' })
                        return false
                    }

                    const { state } = editor
                    const { tr } = state
                    let deletions = []

                    // Find all promptSnippetList nodes
                    state.doc.descendants((node, pos) => {
                        if (node.type.name === 'promptSnippetList') {
                            // Check if any child snippets are empty/corrupted
                            let hasCorrupted = false
                            node.forEach((child) => {
                                if (child.type.name === 'promptSnippet') {
                                    let titleText = ''
                                    let bodyText = ''
                                    child.forEach((grandchild) => {
                                        if (grandchild.type.name === 'promptSnippetTitle') {
                                            titleText = grandchild.textContent.trim()
                                        } else if (grandchild.type.name === 'promptSnippetBody') {
                                            bodyText = grandchild.textContent.trim()
                                        }
                                    })
                                    // Consider empty snippets as corrupted
                                    if (!titleText && !bodyText) {
                                        hasCorrupted = true
                                    }
                                }
                            })

                            if (hasCorrupted) {
                                deletions.push({ from: pos, to: pos + node.nodeSize })
                            }
                        }
                    })

                    sendToSwift({ type: 'debug', message: `Found ${deletions.length} corrupted snippet lists` })

                    if (deletions.length === 0) {
                        return false
                    }

                    // Delete in reverse order to maintain positions
                    deletions.sort((a, b) => b.from - a.from)
                    for (const del of deletions) {
                        tr.delete(del.from, del.to)
                        // Insert a paragraph to replace deleted content
                        tr.insert(del.from, state.schema.nodes.paragraph.create())
                    }

                    editor.view.dispatch(tr)
                    sendToSwift({ type: 'debug', message: `Removed ${deletions.length} corrupted snippet lists` })
                    return true
                },

                // Force delete ALL snippet lists in the document (nuclear option)
                removeAllSnippets: () => {
                    if (!editor) {
                        sendToSwift({ type: 'debug', message: 'No editor to clean' })
                        return false
                    }

                    const { state } = editor
                    const { tr } = state
                    let deletions = []

                    // Find all promptSnippetList nodes
                    state.doc.descendants((node, pos) => {
                        if (node.type.name === 'promptSnippetList') {
                            deletions.push({ from: pos, to: pos + node.nodeSize })
                        }
                    })

                    sendToSwift({ type: 'debug', message: `Found ${deletions.length} snippet lists to remove` })

                    if (deletions.length === 0) {
                        return false
                    }

                    // Delete in reverse order to maintain positions
                    deletions.sort((a, b) => b.from - a.from)
                    for (const del of deletions) {
                        tr.delete(del.from, del.to)
                        tr.insert(del.from, state.schema.nodes.paragraph.create())
                    }

                    editor.view.dispatch(tr)
                    sendToSwift({ type: 'debug', message: `Removed ${deletions.length} snippet lists` })
                    return true
                }
            };
            
            sendToSwift({ type: 'ready' });
            sendToSwift({ type: 'debug', message: 'Editor initialized with Yjs collaboration!' });
        }
        
        // ============================================
        // Bootstrap (wait for native app to call initDocument)
        // ============================================
        sendToSwift({ type: 'debug', message: 'Collaborative editor loaded, waiting for initDocument...' })
        
        // Expose initialization function globally
        window.initDocument = (documentId, config = {}) => {
            sendToSwift({ type: 'debug', message: `initDocument called with: ${documentId}` })
            
            if (config.partyKitHost) PARTYKIT_HOST = config.partyKitHost
            if (config.userId) USER_ID = config.userId
            if (config.userName) USER_NAME = config.userName
            if (config.userColor) USER_COLOR = config.userColor
            
            const ydoc = initializeYjs(documentId)
            
            // Wait for IndexedDB to sync, then create editor
            if (indexeddbProvider.synced) {
                sendToSwift({ type: 'debug', message: 'IndexedDB already synced!' })
                const content = ydoc.getXmlFragment('content')
                sendToSwift({ type: 'debug', message: `Content ready: ${content.length} items` })
                initializeEditor(ydoc)
            } else {
                sendToSwift({ type: 'debug', message: 'Waiting for IndexedDB sync...' })
                indexeddbProvider.once('synced', () => {
                    sendToSwift({ type: 'debug', message: 'IndexedDB now synced!' })
                    const content = ydoc.getXmlFragment('content')
                    sendToSwift({ type: 'debug', message: `Content ready: ${content.length} items` })
                    initializeEditor(ydoc)
                })
            }
        }
        
        // Send ready signal so native app knows we're loaded
        sendToSwift({ type: 'editorLoaded' })
    </script>
</body>
</html>
